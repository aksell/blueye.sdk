{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"blueye.sdk Read Latest Documentation - Browse GitHub Code Repository Note: This is a pre-release -- Please report any issues you might encounter A Python package for remote control of the Blueye Pioneer underwater drone. About The Pioneer The Blueye Pioneer is a underwater drone designed for inspections. It is produced and sold by the Norwegian company Blueye Robotics . Here is a Youtube video that gives a overview of the system and its specifications. This SDK and the Pioneer The Pioneer is normally controlled via a mobile device through the Blueye App ( iOS / Android ). The mobile device is connected via WiFi to a surface unit, and the Pioneer is connected to the surface unit via a tether cable. This python SDK exposes the functionality of the Blueye app through a Python object. The SDK enables remote control of the Pioneer as well as reading telemetry data and viewing video streams, it is not meant for executing code on the Pioneer. To control the Pioneer you connect your laptop to the surface unit WiFi and run code that interfaces with the Pioneer through the Pioneer Python object. Check out the Quick Start Guide to get started with using the SDK.","title":"About the Pioneer"},{"location":"#blueyesdk","text":"Read Latest Documentation - Browse GitHub Code Repository Note: This is a pre-release -- Please report any issues you might encounter A Python package for remote control of the Blueye Pioneer underwater drone.","title":"blueye.sdk"},{"location":"#about-the-pioneer","text":"The Blueye Pioneer is a underwater drone designed for inspections. It is produced and sold by the Norwegian company Blueye Robotics . Here is a Youtube video that gives a overview of the system and its specifications.","title":"About The Pioneer"},{"location":"#this-sdk-and-the-pioneer","text":"The Pioneer is normally controlled via a mobile device through the Blueye App ( iOS / Android ). The mobile device is connected via WiFi to a surface unit, and the Pioneer is connected to the surface unit via a tether cable. This python SDK exposes the functionality of the Blueye app through a Python object. The SDK enables remote control of the Pioneer as well as reading telemetry data and viewing video streams, it is not meant for executing code on the Pioneer. To control the Pioneer you connect your laptop to the surface unit WiFi and run code that interfaces with the Pioneer through the Pioneer Python object. Check out the Quick Start Guide to get started with using the SDK.","title":"This SDK and the Pioneer"},{"location":"contributing/","text":"Development Project structure and context blueye.sdk is a Python package that exposes the functionality of the Blueye app. The SDK depends on three projects: ProtocolDefinitons : TCP commands are sent from a computer or mobile device to the drone, and UDP messages with telemetry data are sent from the drone back to the top side device. These TCP commands and UDP telemetry messages are defined as json files in this project. blueye.protocol : Implements a TCP client for connecting to the Pioneer and sending the TCP commands defined in ProtocolDefinitions , and a UDP client for receiving and parsing the telemetry messages defined in ProtocolDefinitions blueye.sdk : Wraps the TCP and UDP client from blueye.protocol into an easy to use Python object. blueye.sdk also adds functionality for downloading log files from the drone. Tests To run the tests when connected to a surface unit with an active drone, do: pytest To run tests when not connected to a drone, do: pytest -k \"not connected_to_drone\" Documentation The documentation is written in markdown and converted to html with portray . To generate and open the documentation locally run portray in_browser Formatting To keep the code style consistent Black is used for code formatting. To format code with black run black . in the project root directory. Adding a pre-commit hook ensures black is run before every commit pre-commit install adds a pre-commit hook for black formatting. Can't find what you are looking for? This SDK is still very much a work in progress, if you feel features are missing or something feels clunky, please open an issue and suggest a change. Bug reports and fixes are of course always welcome!","title":"Development"},{"location":"contributing/#development","text":"","title":"Development"},{"location":"contributing/#project-structure-and-context","text":"blueye.sdk is a Python package that exposes the functionality of the Blueye app. The SDK depends on three projects: ProtocolDefinitons : TCP commands are sent from a computer or mobile device to the drone, and UDP messages with telemetry data are sent from the drone back to the top side device. These TCP commands and UDP telemetry messages are defined as json files in this project. blueye.protocol : Implements a TCP client for connecting to the Pioneer and sending the TCP commands defined in ProtocolDefinitions , and a UDP client for receiving and parsing the telemetry messages defined in ProtocolDefinitions blueye.sdk : Wraps the TCP and UDP client from blueye.protocol into an easy to use Python object. blueye.sdk also adds functionality for downloading log files from the drone.","title":"Project structure and context"},{"location":"contributing/#tests","text":"To run the tests when connected to a surface unit with an active drone, do: pytest To run tests when not connected to a drone, do: pytest -k \"not connected_to_drone\"","title":"Tests"},{"location":"contributing/#documentation","text":"The documentation is written in markdown and converted to html with portray . To generate and open the documentation locally run portray in_browser","title":"Documentation"},{"location":"contributing/#formatting","text":"To keep the code style consistent Black is used for code formatting. To format code with black run black . in the project root directory. Adding a pre-commit hook ensures black is run before every commit pre-commit install adds a pre-commit hook for black formatting.","title":"Formatting"},{"location":"contributing/#cant-find-what-you-are-looking-for","text":"This SDK is still very much a work in progress, if you feel features are missing or something feels clunky, please open an issue and suggest a change. Bug reports and fixes are of course always welcome!","title":"Can't find what you are looking for?"},{"location":"docs/quick_start/","text":"Installation The SDK requires Python 3.7 or higher. Since many operating systems do not package the newest version of Python we recommend using pyenv or something similar for configuring multiple python versions on the same system. Pyenv also has the added benefit of managing your virtual environments for you, though you are of course free to use other tools for that as well. The instructions below show the necessary steps to get started with the SDK on a fresh install: Windows Install Python Install Python 3.7 or higher, you can find the latest python versions here . Remember to check the option \"Add Python to path\" when installing. Install virtualenv for managing Python versions (optional) Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages. # Upgrade pip version python -m pip install --upgrade pip pip install virtualenv Next, we create a virtual environment cd . \\D esktop mkdir pioneer_project cd . \\p ioneer_project # Replace \"C:\\Program Files\\Python37\\python.exe\" with the path # to the python version you want to use in the line below virtualenv blueye_sdk_env -p \"C:\\Program Files\\Python37\\python.exe\" activate the virtual environment . \\b lueye_sdk_env \\S cripts \\a ctivate.bat if you are not allowed to activate the virtual environment, you might have to allow running unsigned scripts, see this link for instructions. Install the SDK Now we're ready to install the SDK, which should be as simple as pip install blueye.sdk or, if you want to include the dependencies required for running the examples shown in this documentation you should run pip install \"blueye.sdk[examples]\" Mac OS Install the necessary Python version Install pyenv, for more instructions see the pyenv-installer curl https://pyenv.run | bash pyenv update If you want pyenv to be loaded each time you open a new terminal you can add this to your .zshrc or the equivalent for your terminal export PATH=\"$HOME/.pyenv/bin:$PATH\" eval \"$(pyenv init -)\" eval \"$(pyenv virtualenv-init -)\" The Pyenv wiki recommends installing some additional dependencies before building Python. # optional, but recommended: brew install openssl readline sqlite3 xz zlib When running Mojave or higher (10.14+) you will also need to install the additional SDK headers: sudo installer -pkg /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg -target / Then build Python with pyenv pyenv install 3.8.0 Create a virtual environment Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages. Since we already have pyenv installed we'll use it to create a virtual environment, pyenv virtualenv 3.8.0 blueye.sdk pyenv activate blueye.sdk Install the SDK Now we're ready to install the SDK, which should be as simple as. pip install blueye.sdk or, if you want to include the dependencies required for running the examples shown in this documentation you should run pip install \"blueye.sdk[examples]\" Linux These instructions are directed at Ubuntu, but the process should be similar for other distributions. Install the necessary Python version Install pyenv, for more instructions see the pyenv-installer curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash pyenv update Install the needed dependencies for building python 3.8.0 apt install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \\ libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \\ xz-utils tk-dev libffi-dev liblzma-dev python-openssl Then build python with pyenv pyenv install 3.8.0 Create a virtual environment Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages. Since we already have pyenv installed we'll use it to create a virtual environment, pyenv virtualenv 3.8.0 blueye.sdk pyenv activate blueye.sdk Install the SDK Now we're ready to install the SDK, which should be as simple as pip install blueye.sdk or, if you want to include the dependencies required for running the examples shown in this documentation you should run pip install \"blueye.sdk[examples]\" Connect to the Pioneer To use the SDK your computer must be connected to the Pioneer via the surface unit WiFi. Turn on the drone and connect to the surface unit WiFi. For a how to on turning on the Pioneer and surface unit you can watch the quick start video . Control the Pioneer Most of the pioneers functionality is controlled using python properties, we can illustrate the use of properties by showing how to control the lights through the lights property of the Pioneer. import time from blueye.sdk import Pioneer # when the pioneer object is instantiatied a connection to the drone is established p = Pioneer () # setting the lights property of the Pioneer object to 10 p . lights = 10 time . sleep ( 2 ) # we can also get the current brightness of the lights through the lights property print ( f \"Current light intensity: {p.lights}\" ) p . lights = 0 # properties can also be used for reading telemetry data from the drone print ( f \"Current depth in millimeters: {p.depth}\" ) For a overview of the properties that are availabe for controlling and reading data from the Pioneer, go to the Reference section of the documentation.The valid input ranges and descriptions of the different properties can also be found there. Watching the video stream The easiest way to open the RTSP video stream is using VLC media player . Once VLC is downloaded you can start the stream like this, the RTSP URL is: rtsp://192.168.1.101:8554/test For lower latency streaming (on a PC) you can see the instructions on using Gstreamer , or if you just want to watch a low latency stream you can download the Blueye Dive Buddy ( iOS / Android ) The normal Blueye app can not be used to spectate when controlling the drone from the SDK because it will interfere with the commands sent from the SDK. The dive buddy app, however, is only a spectator and can be used together with the SDK. Explore the examples For further examples on how to use the SDK to control the Pioneer have a look at the motion examples . Remember to install the example dependencies before running the examples. pip install \"blueye.sdk[examples]\"","title":"Quick Start"},{"location":"docs/quick_start/#installation","text":"The SDK requires Python 3.7 or higher. Since many operating systems do not package the newest version of Python we recommend using pyenv or something similar for configuring multiple python versions on the same system. Pyenv also has the added benefit of managing your virtual environments for you, though you are of course free to use other tools for that as well. The instructions below show the necessary steps to get started with the SDK on a fresh install: Windows Install Python Install Python 3.7 or higher, you can find the latest python versions here . Remember to check the option \"Add Python to path\" when installing. Install virtualenv for managing Python versions (optional) Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages. # Upgrade pip version python -m pip install --upgrade pip pip install virtualenv Next, we create a virtual environment cd . \\D esktop mkdir pioneer_project cd . \\p ioneer_project # Replace \"C:\\Program Files\\Python37\\python.exe\" with the path # to the python version you want to use in the line below virtualenv blueye_sdk_env -p \"C:\\Program Files\\Python37\\python.exe\" activate the virtual environment . \\b lueye_sdk_env \\S cripts \\a ctivate.bat if you are not allowed to activate the virtual environment, you might have to allow running unsigned scripts, see this link for instructions. Install the SDK Now we're ready to install the SDK, which should be as simple as pip install blueye.sdk or, if you want to include the dependencies required for running the examples shown in this documentation you should run pip install \"blueye.sdk[examples]\" Mac OS Install the necessary Python version Install pyenv, for more instructions see the pyenv-installer curl https://pyenv.run | bash pyenv update If you want pyenv to be loaded each time you open a new terminal you can add this to your .zshrc or the equivalent for your terminal export PATH=\"$HOME/.pyenv/bin:$PATH\" eval \"$(pyenv init -)\" eval \"$(pyenv virtualenv-init -)\" The Pyenv wiki recommends installing some additional dependencies before building Python. # optional, but recommended: brew install openssl readline sqlite3 xz zlib When running Mojave or higher (10.14+) you will also need to install the additional SDK headers: sudo installer -pkg /Library/Developer/CommandLineTools/Packages/macOS_SDK_headers_for_macOS_10.14.pkg -target / Then build Python with pyenv pyenv install 3.8.0 Create a virtual environment Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages. Since we already have pyenv installed we'll use it to create a virtual environment, pyenv virtualenv 3.8.0 blueye.sdk pyenv activate blueye.sdk Install the SDK Now we're ready to install the SDK, which should be as simple as. pip install blueye.sdk or, if you want to include the dependencies required for running the examples shown in this documentation you should run pip install \"blueye.sdk[examples]\" Linux These instructions are directed at Ubuntu, but the process should be similar for other distributions. Install the necessary Python version Install pyenv, for more instructions see the pyenv-installer curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash pyenv update Install the needed dependencies for building python 3.8.0 apt install -y make build-essential libssl-dev zlib1g-dev libbz2-dev \\ libreadline-dev libsqlite3-dev wget curl llvm libncurses5-dev libncursesw5-dev \\ xz-utils tk-dev libffi-dev liblzma-dev python-openssl Then build python with pyenv pyenv install 3.8.0 Create a virtual environment Using a virtual environment is not strictly necessary, but it greatly simplifies the development of Python packages. Since we already have pyenv installed we'll use it to create a virtual environment, pyenv virtualenv 3.8.0 blueye.sdk pyenv activate blueye.sdk Install the SDK Now we're ready to install the SDK, which should be as simple as pip install blueye.sdk or, if you want to include the dependencies required for running the examples shown in this documentation you should run pip install \"blueye.sdk[examples]\"","title":"Installation"},{"location":"docs/quick_start/#connect-to-the-pioneer","text":"To use the SDK your computer must be connected to the Pioneer via the surface unit WiFi. Turn on the drone and connect to the surface unit WiFi. For a how to on turning on the Pioneer and surface unit you can watch the quick start video .","title":"Connect to the Pioneer"},{"location":"docs/quick_start/#control-the-pioneer","text":"Most of the pioneers functionality is controlled using python properties, we can illustrate the use of properties by showing how to control the lights through the lights property of the Pioneer. import time from blueye.sdk import Pioneer # when the pioneer object is instantiatied a connection to the drone is established p = Pioneer () # setting the lights property of the Pioneer object to 10 p . lights = 10 time . sleep ( 2 ) # we can also get the current brightness of the lights through the lights property print ( f \"Current light intensity: {p.lights}\" ) p . lights = 0 # properties can also be used for reading telemetry data from the drone print ( f \"Current depth in millimeters: {p.depth}\" ) For a overview of the properties that are availabe for controlling and reading data from the Pioneer, go to the Reference section of the documentation.The valid input ranges and descriptions of the different properties can also be found there.","title":"Control the Pioneer"},{"location":"docs/quick_start/#watching-the-video-stream","text":"The easiest way to open the RTSP video stream is using VLC media player . Once VLC is downloaded you can start the stream like this, the RTSP URL is: rtsp://192.168.1.101:8554/test For lower latency streaming (on a PC) you can see the instructions on using Gstreamer , or if you just want to watch a low latency stream you can download the Blueye Dive Buddy ( iOS / Android ) The normal Blueye app can not be used to spectate when controlling the drone from the SDK because it will interfere with the commands sent from the SDK. The dive buddy app, however, is only a spectator and can be used together with the SDK.","title":"Watching the video stream"},{"location":"docs/quick_start/#explore-the-examples","text":"For further examples on how to use the SDK to control the Pioneer have a look at the motion examples . Remember to install the example dependencies before running the examples. pip install \"blueye.sdk[examples]\"","title":"Explore the examples"},{"location":"docs/logs/listing-and-downloading/","text":"Logs from the Pioneer For every dive will the Pioneer will create a new comma-separated-value file where it stores telemetry data such as depth, temperature, etc. These files can be downloaded to your local system where you can plot them or use them however you see fit. Listing the log files If your drone has completed 5 dives and you do from blueye.sdk import Pioneer p = Pioneer () print ( p . logs ) you should see something like the following lines be printed Name Time Max depth Size ea9add4d40f69d4-00000.csv 24. Oct 2018 09:40 21.05 m 6.3 MiB ea9add4d40f69d4-00001.csv 25. Oct 2018 10:29 21.06 m 879.2 KiB ea9add4d40f69d4-00002.csv 31. Oct 2018 10:05 60.69 m 8.5 MiB ea9add4d40f69d4-00003.csv 31. Oct 2018 12:13 41.68 m 8.4 MiB ea9add4d40f69d4-00004.csv 02. Nov 2018 08:59 52.52 m 7.8 MiB The first part of the filename (the part before the -) is the unique ID of your drone and second part is the dive number. In addition we see the start time of the dive, the maximum depth reached, as well as the size of the log file. Downloading a log file to your computer When you want to download a log file all you have to do is to call the download() method on the desired log and the file will be downloaded to your current folder. The download() method takes two optional parameters, output_path and output_name . These specify, respectively, which folder the log is downloaded to and what name it's stored with. Example: Downloading multiple log files Downloading multiple log files is solved by a simple Python for-loop. The example below shows how one can download the last 3 logs to the current folder: from blueye.sdk import Pioneer p = Pioneer () for log in p . logs [: - 3 ]: log . download () Example: Adding a prefix to log names The example code below shows how one can add a simple prefix to all log files when downloading: from blueye.sdk import Pioneer p = Pioneer () prefix = \"pre_\" for log in p . logs : log . download ( output_name = prefix + log . name )","title":"Listing and downloading log files"},{"location":"docs/logs/listing-and-downloading/#logs-from-the-pioneer","text":"For every dive will the Pioneer will create a new comma-separated-value file where it stores telemetry data such as depth, temperature, etc. These files can be downloaded to your local system where you can plot them or use them however you see fit.","title":"Logs from the Pioneer"},{"location":"docs/logs/listing-and-downloading/#listing-the-log-files","text":"If your drone has completed 5 dives and you do from blueye.sdk import Pioneer p = Pioneer () print ( p . logs ) you should see something like the following lines be printed Name Time Max depth Size ea9add4d40f69d4-00000.csv 24. Oct 2018 09:40 21.05 m 6.3 MiB ea9add4d40f69d4-00001.csv 25. Oct 2018 10:29 21.06 m 879.2 KiB ea9add4d40f69d4-00002.csv 31. Oct 2018 10:05 60.69 m 8.5 MiB ea9add4d40f69d4-00003.csv 31. Oct 2018 12:13 41.68 m 8.4 MiB ea9add4d40f69d4-00004.csv 02. Nov 2018 08:59 52.52 m 7.8 MiB The first part of the filename (the part before the -) is the unique ID of your drone and second part is the dive number. In addition we see the start time of the dive, the maximum depth reached, as well as the size of the log file.","title":"Listing the log files"},{"location":"docs/logs/listing-and-downloading/#downloading-a-log-file-to-your-computer","text":"When you want to download a log file all you have to do is to call the download() method on the desired log and the file will be downloaded to your current folder. The download() method takes two optional parameters, output_path and output_name . These specify, respectively, which folder the log is downloaded to and what name it's stored with.","title":"Downloading a log file to your computer"},{"location":"docs/logs/listing-and-downloading/#example-downloading-multiple-log-files","text":"Downloading multiple log files is solved by a simple Python for-loop. The example below shows how one can download the last 3 logs to the current folder: from blueye.sdk import Pioneer p = Pioneer () for log in p . logs [: - 3 ]: log . download ()","title":"Example: Downloading multiple log files"},{"location":"docs/logs/listing-and-downloading/#example-adding-a-prefix-to-log-names","text":"The example code below shows how one can add a simple prefix to all log files when downloading: from blueye.sdk import Pioneer p = Pioneer () prefix = \"pre_\" for log in p . logs : log . download ( output_name = prefix + log . name )","title":"Example: Adding a prefix to log names"},{"location":"docs/logs/log-file-format/","text":"Log file format The log files from the Blueye Pioneer are in essence a recording of the data that is published over UDP stored as a comma-separated-value (CSV) file. The rest of this page documents the most useful fields of the log files. The column indices listed are zero-based. If you feel that some fields need more documentation, feel free to open an issue on Github , and we'll happily supply the requested information. Time Column Type Unit Description 2 Integer Milliseconds The elapsed time since the start of the log 3 Float Unix timestamp Global time Position The position is based on the user's phone's GPS at the start of the dive. Column Type Unit Description 6 Float Degrees Latitude 7 Float Degrees Longitude File storage Column Type Unit Description 8 Integer Bytes Total file storage on the drone 9 Integer Bytes Available free space Temperature Note: All temperatures are in \"deci-degrees Celsius\", ie. to get \u00b0C you need to divide the value by 10. Column Type Unit Description 11 Integer Deci-Celsius Bottom canister temperature 12 Integer Deci-Celsius Water temperature 13 Integer Deci-Celsius Top canister temperature 14 Integer Deci-Celsius CPU temperature Internal humidity Note: The unit is in deci-percent (ie. divide by 10 to get percent). Column Type Unit Description 15 Integer Deci-percent Humidity in the top canister. 16 Integer Deci-percent Humidity in the bottom canister. Lights Column Type Unit Description 17 Integer - State the of the Pioneers on-board light. Range is 0 to 255. Depth Column Type Unit Description 22 Integer Milli-meters Depth below water surface. Positive values are below the surface, negative are above. Control force Control force is the force exerted on the drone by the control system. Column Type Unit Description 29 Float Newton Force in the surge direction. 30 Float Newton Force in the sway direction. 31 Float Newton Force in the heave direction. 32 Float Newton Force in the yaw direction. Orientation (pose) Column Type Unit Description 32 Float Degrees Roll angle. Range from -180\u00b0 - 180\u00b0 33 Float Degrees Pitch angle. Range from -180\u00b0 - 180\u00b0 34 Float Degrees Yaw angle. Range from -180\u00b0 - 180\u00b0 Battery Column Type Unit Description 38 Integer Milli-volts Battery voltage 39 Integer Milli-amperes Battery current. Negative values are drained from the battery, positive are charged. 41 Integer Percent Relative state of charge. Range from 0 - 100 %","title":"Log file format"},{"location":"docs/logs/log-file-format/#log-file-format","text":"The log files from the Blueye Pioneer are in essence a recording of the data that is published over UDP stored as a comma-separated-value (CSV) file. The rest of this page documents the most useful fields of the log files. The column indices listed are zero-based. If you feel that some fields need more documentation, feel free to open an issue on Github , and we'll happily supply the requested information.","title":"Log file format"},{"location":"docs/logs/log-file-format/#time","text":"Column Type Unit Description 2 Integer Milliseconds The elapsed time since the start of the log 3 Float Unix timestamp Global time","title":"Time"},{"location":"docs/logs/log-file-format/#position","text":"The position is based on the user's phone's GPS at the start of the dive. Column Type Unit Description 6 Float Degrees Latitude 7 Float Degrees Longitude","title":"Position"},{"location":"docs/logs/log-file-format/#file-storage","text":"Column Type Unit Description 8 Integer Bytes Total file storage on the drone 9 Integer Bytes Available free space","title":"File storage"},{"location":"docs/logs/log-file-format/#temperature","text":"Note: All temperatures are in \"deci-degrees Celsius\", ie. to get \u00b0C you need to divide the value by 10. Column Type Unit Description 11 Integer Deci-Celsius Bottom canister temperature 12 Integer Deci-Celsius Water temperature 13 Integer Deci-Celsius Top canister temperature 14 Integer Deci-Celsius CPU temperature","title":"Temperature"},{"location":"docs/logs/log-file-format/#internal-humidity","text":"Note: The unit is in deci-percent (ie. divide by 10 to get percent). Column Type Unit Description 15 Integer Deci-percent Humidity in the top canister. 16 Integer Deci-percent Humidity in the bottom canister.","title":"Internal humidity"},{"location":"docs/logs/log-file-format/#lights","text":"Column Type Unit Description 17 Integer - State the of the Pioneers on-board light. Range is 0 to 255.","title":"Lights"},{"location":"docs/logs/log-file-format/#depth","text":"Column Type Unit Description 22 Integer Milli-meters Depth below water surface. Positive values are below the surface, negative are above.","title":"Depth"},{"location":"docs/logs/log-file-format/#control-force","text":"Control force is the force exerted on the drone by the control system. Column Type Unit Description 29 Float Newton Force in the surge direction. 30 Float Newton Force in the sway direction. 31 Float Newton Force in the heave direction. 32 Float Newton Force in the yaw direction.","title":"Control force"},{"location":"docs/logs/log-file-format/#orientation-pose","text":"Column Type Unit Description 32 Float Degrees Roll angle. Range from -180\u00b0 - 180\u00b0 33 Float Degrees Pitch angle. Range from -180\u00b0 - 180\u00b0 34 Float Degrees Yaw angle. Range from -180\u00b0 - 180\u00b0","title":"Orientation (pose)"},{"location":"docs/logs/log-file-format/#battery","text":"Column Type Unit Description 38 Integer Milli-volts Battery voltage 39 Integer Milli-amperes Battery current. Negative values are drained from the battery, positive are charged. 41 Integer Percent Relative state of charge. Range from 0 - 100 %","title":"Battery"},{"location":"docs/logs/plotting/","text":"Plotting This example shows how one can pull a log file from the drone and use pandas and matplotlib to plot it. We'll start by downloading a log file from the drone from blueye.sdk import Pioneer p = Pioneer () p . logs [ 0 ] . download ( outputName = \"log0.csv\" ) We can now read the csv-file into a pandas object for easy manipulation import pandas divelog = pandas . read_csv ( \"log0.csv\" ) and then we'll convert the unix timestamp in rt_clock into a more readable format: divelog [ \"rt_clock\" ] = pandas . to_datetime ( divelog [ \"rt_clock\" ], unit = \"s\" ) Next we will plot depth vs time with matplotlib: import matplotlib.pyplot as plt # Instantiate our figure and axes to plot on figure , axes = plt . subplots () x = divelog [ \"rt_clock\" ] y = divelog [ \"depth\" ] / 1000 # Dividing by 1000 to get depth in meters # Plot the depth values against time axes . plot ( x , y , label = \"depth\" ) # Set title, labels, and legend plt . title ( \"Depth chart\" ) plt . xlabel ( \"Time\" ) plt . ylabel ( \"Depth [m]\" ) plt . legend () # Save the figure figure . savefig ( \"depth_plot.svg\" ) This should yield us a plot that looks something like this: See the matplotlib documentation for more ways to plot your data.","title":"Plotting log files"},{"location":"docs/logs/plotting/#plotting","text":"This example shows how one can pull a log file from the drone and use pandas and matplotlib to plot it. We'll start by downloading a log file from the drone from blueye.sdk import Pioneer p = Pioneer () p . logs [ 0 ] . download ( outputName = \"log0.csv\" ) We can now read the csv-file into a pandas object for easy manipulation import pandas divelog = pandas . read_csv ( \"log0.csv\" ) and then we'll convert the unix timestamp in rt_clock into a more readable format: divelog [ \"rt_clock\" ] = pandas . to_datetime ( divelog [ \"rt_clock\" ], unit = \"s\" ) Next we will plot depth vs time with matplotlib: import matplotlib.pyplot as plt # Instantiate our figure and axes to plot on figure , axes = plt . subplots () x = divelog [ \"rt_clock\" ] y = divelog [ \"depth\" ] / 1000 # Dividing by 1000 to get depth in meters # Plot the depth values against time axes . plot ( x , y , label = \"depth\" ) # Set title, labels, and legend plt . title ( \"Depth chart\" ) plt . xlabel ( \"Time\" ) plt . ylabel ( \"Depth [m]\" ) plt . legend () # Save the figure figure . savefig ( \"depth_plot.svg\" ) This should yield us a plot that looks something like this: See the matplotlib documentation for more ways to plot your data.","title":"Plotting"},{"location":"docs/movement/from-the-CLI/","text":"Controlling from the Command Line Interface This is a super simple example showing how you make the drone move from the command line interface: import time from blueye.sdk import Pioneer p = Pioneer () p . motion . surge = 1 time . sleep ( 1 ) p . motion . surge = 0","title":"Control from the CLI"},{"location":"docs/movement/from-the-CLI/#controlling-from-the-command-line-interface","text":"This is a super simple example showing how you make the drone move from the command line interface: import time from blueye.sdk import Pioneer p = Pioneer () p . motion . surge = 1 time . sleep ( 1 ) p . motion . surge = 0","title":"Controlling from the Command Line Interface"},{"location":"docs/movement/with-a-gamepad/","text":"Controlling the drone from a gamepad To run the example remember to first install the optional dependencies needed for running the examples pip install \"blueye.sdk[examples]\" The example below illustrates how one could use an Xbox controller and the SDK to control the drone. The inputs library supports many other gamepads, so using a different controller should be as simple as looking up the event codes for the buttons/axes and mapping them to the functions you want. import inputs from blueye.sdk import Pioneer class JoystickHandler : \"\"\"Maps pioneer functions to joystick events\"\"\" def __init__ ( self , pioneer ): self . pioneer = pioneer self . eventToFunctionMap = { \"BTN_NORTH\" : self . handleXButton , \"BTN_WEST\" : self . handleYButton , \"BTN_EAST\" : self . handleBButton , \"BTN_SOUTH\" : self . handleAButton , \"ABS_X\" : self . handleLeftXAxis , \"ABS_Y\" : self . handleLeftYAxis , \"ABS_RX\" : self . handleRightXAxis , \"ABS_RY\" : self . handleRightYAxis , } def handleXButton ( self , value ): \"\"\"Starts/stops the video recording\"\"\" self . pioneer . camera . is_recording = value def handleYButton ( self , value ): \"\"\"Turns lights on or off\"\"\" if value : if self . pioneer . lights > 0 : self . pioneer . lights = 0 else : self . pioneer . lights = 10 def handleBButton ( self , value ): \"\"\"Toggles autoheading\"\"\" if value : self . pioneer . motion . auto_heading_active = ( not self . pioneer . motion . auto_heading_active ) def handleAButton ( self , value ): \"\"\"Toggles autodepth\"\"\" if value : self . pioneer . motion . auto_depth_active = ( not self . pioneer . motion . auto_depth_active ) def filterAndNormalize ( self , value , lower = 5000 , upper = 32768 ): \"\"\"Normalizing the joystick axis range from (default) -32768<->32678 to -1<->1 The sticks also tend to not stop at 0 when you let them go but rather some low value, so we'll filter those out as well. \"\"\" if - lower < value < lower : return 0 elif lower < value < upper : return ( value - lower ) / ( upper - lower ) elif - upper < value < - lower : return ( value + lower ) / ( upper - lower ) else : return 0 def handleLeftXAxis ( self , value ): self . pioneer . motion . yaw = self . filterAndNormalize ( value ) def handleLeftYAxis ( self , value ): self . pioneer . motion . heave = self . filterAndNormalize ( value ) def handleRightXAxis ( self , value ): self . pioneer . motion . sway = self . filterAndNormalize ( value ) def handleRightYAxis ( self , value ): self . pioneer . motion . surge = - self . filterAndNormalize ( value ) if __name__ == \"__main__\" : try : p = Pioneer () handler = JoystickHandler ( p ) while True : events = inputs . get_gamepad () for event in events : if event . code in handler . eventToFunctionMap : handler . eventToFunctionMap [ event . code ]( event . state ) except KeyboardInterrupt : pass","title":"Control with a gamepad"},{"location":"docs/movement/with-a-gamepad/#controlling-the-drone-from-a-gamepad","text":"To run the example remember to first install the optional dependencies needed for running the examples pip install \"blueye.sdk[examples]\" The example below illustrates how one could use an Xbox controller and the SDK to control the drone. The inputs library supports many other gamepads, so using a different controller should be as simple as looking up the event codes for the buttons/axes and mapping them to the functions you want. import inputs from blueye.sdk import Pioneer class JoystickHandler : \"\"\"Maps pioneer functions to joystick events\"\"\" def __init__ ( self , pioneer ): self . pioneer = pioneer self . eventToFunctionMap = { \"BTN_NORTH\" : self . handleXButton , \"BTN_WEST\" : self . handleYButton , \"BTN_EAST\" : self . handleBButton , \"BTN_SOUTH\" : self . handleAButton , \"ABS_X\" : self . handleLeftXAxis , \"ABS_Y\" : self . handleLeftYAxis , \"ABS_RX\" : self . handleRightXAxis , \"ABS_RY\" : self . handleRightYAxis , } def handleXButton ( self , value ): \"\"\"Starts/stops the video recording\"\"\" self . pioneer . camera . is_recording = value def handleYButton ( self , value ): \"\"\"Turns lights on or off\"\"\" if value : if self . pioneer . lights > 0 : self . pioneer . lights = 0 else : self . pioneer . lights = 10 def handleBButton ( self , value ): \"\"\"Toggles autoheading\"\"\" if value : self . pioneer . motion . auto_heading_active = ( not self . pioneer . motion . auto_heading_active ) def handleAButton ( self , value ): \"\"\"Toggles autodepth\"\"\" if value : self . pioneer . motion . auto_depth_active = ( not self . pioneer . motion . auto_depth_active ) def filterAndNormalize ( self , value , lower = 5000 , upper = 32768 ): \"\"\"Normalizing the joystick axis range from (default) -32768<->32678 to -1<->1 The sticks also tend to not stop at 0 when you let them go but rather some low value, so we'll filter those out as well. \"\"\" if - lower < value < lower : return 0 elif lower < value < upper : return ( value - lower ) / ( upper - lower ) elif - upper < value < - lower : return ( value + lower ) / ( upper - lower ) else : return 0 def handleLeftXAxis ( self , value ): self . pioneer . motion . yaw = self . filterAndNormalize ( value ) def handleLeftYAxis ( self , value ): self . pioneer . motion . heave = self . filterAndNormalize ( value ) def handleRightXAxis ( self , value ): self . pioneer . motion . sway = self . filterAndNormalize ( value ) def handleRightYAxis ( self , value ): self . pioneer . motion . surge = - self . filterAndNormalize ( value ) if __name__ == \"__main__\" : try : p = Pioneer () handler = JoystickHandler ( p ) while True : events = inputs . get_gamepad () for event in events : if event . code in handler . eventToFunctionMap : handler . eventToFunctionMap [ event . code ]( event . state ) except KeyboardInterrupt : pass","title":"Controlling the drone from a gamepad"},{"location":"docs/video/downloading-videos/","text":"Videos can be downloaded from the drone through the mobile app or by using the Blueye file transfer desktop application for Windows, Mac OS and Linux.","title":"Downloading videos"},{"location":"docs/video/gstreamer-for-video-streaming/","text":"GStreamer is the lowest latency alternative for streaming video from the drone to your laptop. Installing GStreamer To run the streaming pipeline in the next section you will need a runtime installation of GStreamer. The instructions below show the basic steps for installing GStreamer on the most common operating systems. You can find more in depth instruction for your specific operating system in the GStreamer docs . Windows On Windows the basic installation steps are: Download the relevant installer for your computer from https://gstreamer.freedesktop.org/download . Using the latest stable relase should be fine, at the time of writing that is 1.16.1 runtime installer Run the installer. When asked to choose a setup type choose to do a complete installation. This is because some plugins that are needed for the basic pipeline later are not included if you choose to install the typical setup To run GStreamer commands form the terminal, GStreamer must be added to the PATH environment variable. This can be done from the advanced system settings. Add %GSTREAMER_1_0_ROOT_X86_64%\\bin to path. Alternatively you can choose to run gst-launch-1.0.exe from the folder it is installed in, typically C:\\gstreamer\\1.0\\x86_64\\bin Mac OS On Mac OS GStreamer and its plugins can be installed using brew brew install gstreamer gst-plugins-base gst-plugins-good gst-plugins-bad gst-plugins-ugly gst-libav Linux On Ubuntu and Debian GStreamer and its plugins can be installed using apt. apt-get install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good \\ gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc \\ gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa You can test the installation by trying the basic pipeline from the next section when connected to a drone. Or with gst-launch-1.0 videotestsrc ! autovideosink Basic streaming pipeline After installing you can run this pipeline in your terminal: Windows gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8554/test latency = 0 ! rtph264depay ! avdec_h264 ! videoconvert ! fpsdisplaysink sync = false Linux and Mac OS gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8554/test latency = 0 \\ ! rtph264depay \\ ! avdec_h264 \\ ! videoconvert \\ ! fpsdisplaysink sync = false Running the pipeline will open a window with the camera stream and information about packet loss and camera frame rate.","title":"GStreamer for video streaming"},{"location":"docs/video/gstreamer-for-video-streaming/#installing-gstreamer","text":"To run the streaming pipeline in the next section you will need a runtime installation of GStreamer. The instructions below show the basic steps for installing GStreamer on the most common operating systems. You can find more in depth instruction for your specific operating system in the GStreamer docs . Windows On Windows the basic installation steps are: Download the relevant installer for your computer from https://gstreamer.freedesktop.org/download . Using the latest stable relase should be fine, at the time of writing that is 1.16.1 runtime installer Run the installer. When asked to choose a setup type choose to do a complete installation. This is because some plugins that are needed for the basic pipeline later are not included if you choose to install the typical setup To run GStreamer commands form the terminal, GStreamer must be added to the PATH environment variable. This can be done from the advanced system settings. Add %GSTREAMER_1_0_ROOT_X86_64%\\bin to path. Alternatively you can choose to run gst-launch-1.0.exe from the folder it is installed in, typically C:\\gstreamer\\1.0\\x86_64\\bin Mac OS On Mac OS GStreamer and its plugins can be installed using brew brew install gstreamer gst-plugins-base gst-plugins-good gst-plugins-bad gst-plugins-ugly gst-libav Linux On Ubuntu and Debian GStreamer and its plugins can be installed using apt. apt-get install libgstreamer1.0-0 gstreamer1.0-plugins-base gstreamer1.0-plugins-good \\ gstreamer1.0-plugins-bad gstreamer1.0-plugins-ugly gstreamer1.0-libav gstreamer1.0-doc \\ gstreamer1.0-tools gstreamer1.0-x gstreamer1.0-alsa You can test the installation by trying the basic pipeline from the next section when connected to a drone. Or with gst-launch-1.0 videotestsrc ! autovideosink","title":"Installing GStreamer"},{"location":"docs/video/gstreamer-for-video-streaming/#basic-streaming-pipeline","text":"After installing you can run this pipeline in your terminal: Windows gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8554/test latency = 0 ! rtph264depay ! avdec_h264 ! videoconvert ! fpsdisplaysink sync = false Linux and Mac OS gst-launch-1.0 rtspsrc location = rtsp://192.168.1.101:8554/test latency = 0 \\ ! rtph264depay \\ ! avdec_h264 \\ ! videoconvert \\ ! fpsdisplaysink sync = false Running the pipeline will open a window with the camera stream and information about packet loss and camera frame rate.","title":"Basic streaming pipeline"},{"location":"reference/blueye/sdk/","text":"Module blueye.sdk View Source from .pioneer import Pioneer Sub-modules blueye.sdk.camera blueye.sdk.diagnostics blueye.sdk.logs blueye.sdk.motion blueye.sdk.pioneer","title":"Index"},{"location":"reference/blueye/sdk/#module-blueyesdk","text":"View Source from .pioneer import Pioneer","title":"Module blueye.sdk"},{"location":"reference/blueye/sdk/#sub-modules","text":"blueye.sdk.camera blueye.sdk.diagnostics blueye.sdk.logs blueye.sdk.motion blueye.sdk.pioneer","title":"Sub-modules"},{"location":"reference/blueye/sdk/camera/","text":"Module blueye.sdk.camera View Source class Camera: def __init__(self, tcp_client, state_watcher): self._tcp_client = tcp_client self._state_watcher = state_watcher @property def is_recording(self) -> bool: state = self._state_watcher.general_state if state[\"camera_record_time\"] != -1: return True else: return False @is_recording.setter def is_recording(self, start_recording: bool): if start_recording: self._tcp_client.start_recording() else: self._tcp_client.stop_recording() @property def bitrate(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() bitrate = camera_parameters[1] return bitrate @bitrate.setter def bitrate(self, bitrate: int): self._tcp_client.set_camera_bitrate(bitrate) @property def exposure(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() exposure = camera_parameters[2] return exposure @exposure.setter def exposure(self, exposure: int): self._tcp_client.set_camera_exposure(exposure) @property def whitebalance(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() whitebalance = camera_parameters[3] return whitebalance @whitebalance.setter def whitebalance(self, whitebalance: int): self._tcp_client.set_camera_whitebalance(whitebalance) @property def hue(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() hue = camera_parameters[4] return hue @hue.setter def hue(self, hue: int): self._tcp_client.set_camera_hue(hue) @property def resolution(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() resolution = camera_parameters[5] return resolution @resolution.setter def resolution(self, resolution: int): self._tcp_client.set_camera_resolution(resolution) @property def framerate(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() framerate = camera_parameters[6] return framerate @framerate.setter def framerate(self, framerate: int): self._tcp_client.set_camera_framerate(framerate) Classes Camera class Camera ( tcp_client , state_watcher ) View Source class Camera: def __init__(self, tcp_client, state_watcher): self._tcp_client = tcp_client self._state_watcher = state_watcher @property def is_recording(self) -> bool: state = self._state_watcher.general_state if state[\"camera_record_time\"] != -1: return True else: return False @is_recording.setter def is_recording(self, start_recording: bool): if start_recording: self._tcp_client.start_recording() else: self._tcp_client.stop_recording() @property def bitrate(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() bitrate = camera_parameters[1] return bitrate @bitrate.setter def bitrate(self, bitrate: int): self._tcp_client.set_camera_bitrate(bitrate) @property def exposure(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() exposure = camera_parameters[2] return exposure @exposure.setter def exposure(self, exposure: int): self._tcp_client.set_camera_exposure(exposure) @property def whitebalance(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() whitebalance = camera_parameters[3] return whitebalance @whitebalance.setter def whitebalance(self, whitebalance: int): self._tcp_client.set_camera_whitebalance(whitebalance) @property def hue(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() hue = camera_parameters[4] return hue @hue.setter def hue(self, hue: int): self._tcp_client.set_camera_hue(hue) @property def resolution(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() resolution = camera_parameters[5] return resolution @resolution.setter def resolution(self, resolution: int): self._tcp_client.set_camera_resolution(resolution) @property def framerate(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() framerate = camera_parameters[6] return framerate @framerate.setter def framerate(self, framerate: int): self._tcp_client.set_camera_framerate(framerate) Instance variables bitrate exposure framerate hue is_recording resolution whitebalance","title":"Camera"},{"location":"reference/blueye/sdk/camera/#module-blueyesdkcamera","text":"View Source class Camera: def __init__(self, tcp_client, state_watcher): self._tcp_client = tcp_client self._state_watcher = state_watcher @property def is_recording(self) -> bool: state = self._state_watcher.general_state if state[\"camera_record_time\"] != -1: return True else: return False @is_recording.setter def is_recording(self, start_recording: bool): if start_recording: self._tcp_client.start_recording() else: self._tcp_client.stop_recording() @property def bitrate(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() bitrate = camera_parameters[1] return bitrate @bitrate.setter def bitrate(self, bitrate: int): self._tcp_client.set_camera_bitrate(bitrate) @property def exposure(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() exposure = camera_parameters[2] return exposure @exposure.setter def exposure(self, exposure: int): self._tcp_client.set_camera_exposure(exposure) @property def whitebalance(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() whitebalance = camera_parameters[3] return whitebalance @whitebalance.setter def whitebalance(self, whitebalance: int): self._tcp_client.set_camera_whitebalance(whitebalance) @property def hue(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() hue = camera_parameters[4] return hue @hue.setter def hue(self, hue: int): self._tcp_client.set_camera_hue(hue) @property def resolution(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() resolution = camera_parameters[5] return resolution @resolution.setter def resolution(self, resolution: int): self._tcp_client.set_camera_resolution(resolution) @property def framerate(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() framerate = camera_parameters[6] return framerate @framerate.setter def framerate(self, framerate: int): self._tcp_client.set_camera_framerate(framerate)","title":"Module blueye.sdk.camera"},{"location":"reference/blueye/sdk/camera/#classes","text":"","title":"Classes"},{"location":"reference/blueye/sdk/camera/#camera","text":"class Camera ( tcp_client , state_watcher ) View Source class Camera: def __init__(self, tcp_client, state_watcher): self._tcp_client = tcp_client self._state_watcher = state_watcher @property def is_recording(self) -> bool: state = self._state_watcher.general_state if state[\"camera_record_time\"] != -1: return True else: return False @is_recording.setter def is_recording(self, start_recording: bool): if start_recording: self._tcp_client.start_recording() else: self._tcp_client.stop_recording() @property def bitrate(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() bitrate = camera_parameters[1] return bitrate @bitrate.setter def bitrate(self, bitrate: int): self._tcp_client.set_camera_bitrate(bitrate) @property def exposure(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() exposure = camera_parameters[2] return exposure @exposure.setter def exposure(self, exposure: int): self._tcp_client.set_camera_exposure(exposure) @property def whitebalance(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() whitebalance = camera_parameters[3] return whitebalance @whitebalance.setter def whitebalance(self, whitebalance: int): self._tcp_client.set_camera_whitebalance(whitebalance) @property def hue(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() hue = camera_parameters[4] return hue @hue.setter def hue(self, hue: int): self._tcp_client.set_camera_hue(hue) @property def resolution(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() resolution = camera_parameters[5] return resolution @resolution.setter def resolution(self, resolution: int): self._tcp_client.set_camera_resolution(resolution) @property def framerate(self) -> int: camera_parameters = self._tcp_client.get_camera_parameters() framerate = camera_parameters[6] return framerate @framerate.setter def framerate(self, framerate: int): self._tcp_client.set_camera_framerate(framerate)","title":"Camera"},{"location":"reference/blueye/sdk/camera/#instance-variables","text":"bitrate exposure framerate hue is_recording resolution whitebalance","title":"Instance variables"},{"location":"reference/blueye/sdk/diagnostics/","text":"Module blueye.sdk.diagnostics View Source import json import urllib import urllib.error import urllib.request import http.client def get_diagnostic_data(ip, name, port=80, post_data=None, method=None): data = get_website_json( \"http://%s:%d/diagnostics/%s\" % (ip, port, name), post_data, method=method ) return data def get_website_json(url, post_data=None, method=None): retries = 0 while retries < 3: data_json = get_website(url, post_data, method=method) if data_json is not None: break retries += 1 print(\"No data, retriying\") if data_json is None: return None try: data = json.loads(data_json) except json.decoder.JSONDecodeError: print(\"Could not decode json\") return None return data def get_website(url, post_data=None, method=None, decode_utf8=True): try: if method is not None: url = urllib.request.Request(url, method=method) if post_data is not None: post_data = urllib.parse.urlencode(post_data).encode(\"utf-8\") data = urllib.request.urlopen(url, post_data).read() else: data = urllib.request.urlopen(url).read() if decode_utf8: data = data.decode(\"utf-8\") except ConnectionRefusedError: print(\"Could not connect to server\") return None except urllib.error.URLError: print(\"Could not connect to server\") return None except http.client.RemoteDisconnected: print(\"RemoteDisconnect\") return None return data Functions get_diagnostic_data def get_diagnostic_data ( ip , name , port = 80 , post_data = None , method = None ) View Source def get_diagnostic_data(ip, name, port=80, post_data=None, method=None): data = get_website_json( \"http://%s:%d/diagnostics/%s\" % (ip, port, name), post_data, method=method ) return data get_website def get_website ( url , post_data = None , method = None , decode_utf8 = True ) View Source def get_website(url, post_data=None, method=None, decode_utf8=True): try: if method is not None: url = urllib.request.Request(url, method=method) if post_data is not None: post_data = urllib.parse.urlencode(post_data).encode(\"utf-8\") data = urllib.request.urlopen(url, post_data).read() else: data = urllib.request.urlopen(url).read() if decode_utf8: data = data.decode(\"utf-8\") except ConnectionRefusedError: print(\"Could not connect to server\") return None except urllib.error.URLError: print(\"Could not connect to server\") return None except http.client.RemoteDisconnected: print(\"RemoteDisconnect\") return None return data get_website_json def get_website_json ( url , post_data = None , method = None ) View Source def get_website_json(url, post_data=None, method=None): retries = 0 while retries < 3: data_json = get_website(url, post_data, method=method) if data_json is not None: break retries += 1 print(\"No data, retriying\") if data_json is None: return None try: data = json.loads(data_json) except json.decoder.JSONDecodeError: print(\"Could not decode json\") return None return data","title":"Diagnostics"},{"location":"reference/blueye/sdk/diagnostics/#module-blueyesdkdiagnostics","text":"View Source import json import urllib import urllib.error import urllib.request import http.client def get_diagnostic_data(ip, name, port=80, post_data=None, method=None): data = get_website_json( \"http://%s:%d/diagnostics/%s\" % (ip, port, name), post_data, method=method ) return data def get_website_json(url, post_data=None, method=None): retries = 0 while retries < 3: data_json = get_website(url, post_data, method=method) if data_json is not None: break retries += 1 print(\"No data, retriying\") if data_json is None: return None try: data = json.loads(data_json) except json.decoder.JSONDecodeError: print(\"Could not decode json\") return None return data def get_website(url, post_data=None, method=None, decode_utf8=True): try: if method is not None: url = urllib.request.Request(url, method=method) if post_data is not None: post_data = urllib.parse.urlencode(post_data).encode(\"utf-8\") data = urllib.request.urlopen(url, post_data).read() else: data = urllib.request.urlopen(url).read() if decode_utf8: data = data.decode(\"utf-8\") except ConnectionRefusedError: print(\"Could not connect to server\") return None except urllib.error.URLError: print(\"Could not connect to server\") return None except http.client.RemoteDisconnected: print(\"RemoteDisconnect\") return None return data","title":"Module blueye.sdk.diagnostics"},{"location":"reference/blueye/sdk/diagnostics/#functions","text":"","title":"Functions"},{"location":"reference/blueye/sdk/diagnostics/#get_diagnostic_data","text":"def get_diagnostic_data ( ip , name , port = 80 , post_data = None , method = None ) View Source def get_diagnostic_data(ip, name, port=80, post_data=None, method=None): data = get_website_json( \"http://%s:%d/diagnostics/%s\" % (ip, port, name), post_data, method=method ) return data","title":"get_diagnostic_data"},{"location":"reference/blueye/sdk/diagnostics/#get_website","text":"def get_website ( url , post_data = None , method = None , decode_utf8 = True ) View Source def get_website(url, post_data=None, method=None, decode_utf8=True): try: if method is not None: url = urllib.request.Request(url, method=method) if post_data is not None: post_data = urllib.parse.urlencode(post_data).encode(\"utf-8\") data = urllib.request.urlopen(url, post_data).read() else: data = urllib.request.urlopen(url).read() if decode_utf8: data = data.decode(\"utf-8\") except ConnectionRefusedError: print(\"Could not connect to server\") return None except urllib.error.URLError: print(\"Could not connect to server\") return None except http.client.RemoteDisconnected: print(\"RemoteDisconnect\") return None return data","title":"get_website"},{"location":"reference/blueye/sdk/diagnostics/#get_website_json","text":"def get_website_json ( url , post_data = None , method = None ) View Source def get_website_json(url, post_data=None, method=None): retries = 0 while retries < 3: data_json = get_website(url, post_data, method=method) if data_json is not None: break retries += 1 print(\"No data, retriying\") if data_json is None: return None try: data = json.loads(data_json) except json.decoder.JSONDecodeError: print(\"Could not decode json\") return None return data","title":"get_website_json"},{"location":"reference/blueye/sdk/logs/","text":"Module blueye.sdk.logs View Source from datetime import datetime import requests import tabulate class LogFile: \"\"\" This class is a container for a log file stored on the drone The drone lists the file name, max depth, start time, and file size for each log, and you can show this information by printing the log object, eg. on a Pioneer object called `p`: ``` print(p.logs[0]) ``` or, if you want to display the header you can format the object with `with_header`: ``` print(f\"{p.logs[0]:with_header}\") ``` Calling the download() method on a log object will pull the CSV (Comma Separated Value) file from the drone to your local filesystem. \"\"\" def __init__(self, maxdepth, name, timestamp, binsize, ip): self.maxdepth = maxdepth self.name = name self.timestamp = datetime.fromisoformat(timestamp) self.binsize = binsize self.download_path = \"http://\" + ip + \"/logcsv/\" + name self._formatted_values = [ self.name, self.timestamp.strftime(\"%d. %b %Y %H:%M\"), f\"{self.maxdepth/1000:.2f} m\", self._human_readable_filesize(), ] def _human_readable_filesize(self): suffix = \"B\" num = self.binsize for unit in [\"\", \"Ki\", \"Mi\"]: if abs(num) < 1024.0: return f\"{num:3.1f} {unit}{suffix}\" num /= 1024.0 return f\"{num:.1f} Gi{suffix}\" def download(self, output_path=None, output_name=None): \"\"\" Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). \"\"\" log = requests.get(self.download_path).content if output_path is None: output_path = \"./\" if output_name is None: output_name = self.name with open(f\"{output_path}{output_name}\", \"wb\") as f: f.write(log) def __format__(self, format_specifier): if format_specifier == \"with_header\": return tabulate.tabulate( [self], headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" ) else: return tabulate.tabulate([self], tablefmt=\"plain\") def __str__(self): return f\"{self}\" def __getitem__(self, item): return self._formatted_values[item] class Logs: \"\"\"This class is an index of the log files stored on the drone To show the available logs you simply print this object, ie. if your Pioneer object is called `p`, you can do: ``` print(p.logs) ``` This will print a list of all available logs, with some of their metadata, such as name and maxdepth. You can access logfile objects either by index or by name. Eg. if you want the first logfile in the list you can do `p.logs[0]`, or if you want some particular log you can do `p.logs[\"exampleName0001.csv\"]`. You can even give it a slice, so if you want the last 10 logs you can do `p.logs[:-10]`. \"\"\" def __init__(self, ip=\"192.168.1.101\", auto_download_index=True): self.ip = ip if auto_download_index: self.refresh_log_index() else: self._logs = {} def _get_list_of_logs_from_drone(self): list_of_dictionaries = requests.get(\"http://\" + self.ip + \"/logcsv\").json() return list_of_dictionaries def _build_log_files_from_dictionary(self, list_of_logs_in_dictionaries): loglist = {} for log in list_of_logs_in_dictionaries: loglist[log[\"name\"]] = LogFile( log[\"maxdepth\"], log[\"name\"], log[\"timestamp\"], log[\"binsize\"], self.ip ) return loglist def refresh_log_index(self): \"\"\"Refresh the log index from the drone This is method is run on instantiation by default, but if you would like to check for new log files it can be called at any time. \"\"\" list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone() self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries) def __getitem__(self, item): if type(item) == str: try: return self._logs[item] except KeyError: raise KeyError(f\"A log with the name '{item}' does not exist\") else: try: return list(self._logs.values())[item] except IndexError: raise IndexError( f\"Tried to access log nr {item}, \" + f\"but there are only {len(self._logs.values())} logs available\" ) def __str__(self): return tabulate.tabulate( self, headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" ) Classes LogFile class LogFile ( maxdepth , name , timestamp , binsize , ip ) This class is a container for a log file stored on the drone The drone lists the file name, max depth, start time, and file size for each log, and you can show this information by printing the log object, eg. on a Pioneer object called p : print(p.logs[0]) or, if you want to display the header you can format the object with with_header : print(f\"{p.logs[0]:with_header}\") Calling the download() method on a log object will pull the CSV (Comma Separated Value) file from the drone to your local filesystem. View Source class LogFile: \"\"\" This class is a container for a log file stored on the drone The drone lists the file name, max depth, start time, and file size for each log, and you can show this information by printing the log object, eg. on a Pioneer object called `p`: ``` print(p.logs[0]) ``` or, if you want to display the header you can format the object with `with_header`: ``` print(f\"{p.logs[0]:with_header}\") ``` Calling the download() method on a log object will pull the CSV (Comma Separated Value) file from the drone to your local filesystem. \"\"\" def __init__(self, maxdepth, name, timestamp, binsize, ip): self.maxdepth = maxdepth self.name = name self.timestamp = datetime.fromisoformat(timestamp) self.binsize = binsize self.download_path = \"http://\" + ip + \"/logcsv/\" + name self._formatted_values = [ self.name, self.timestamp.strftime(\"%d. %b %Y %H:%M\"), f\"{self.maxdepth/1000:.2f} m\", self._human_readable_filesize(), ] def _human_readable_filesize(self): suffix = \"B\" num = self.binsize for unit in [\"\", \"Ki\", \"Mi\"]: if abs(num) < 1024.0: return f\"{num:3.1f} {unit}{suffix}\" num /= 1024.0 return f\"{num:.1f} Gi{suffix}\" def download(self, output_path=None, output_name=None): \"\"\" Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). \"\"\" log = requests.get(self.download_path).content if output_path is None: output_path = \"./\" if output_name is None: output_name = self.name with open(f\"{output_path}{output_name}\", \"wb\") as f: f.write(log) def __format__(self, format_specifier): if format_specifier == \"with_header\": return tabulate.tabulate( [self], headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" ) else: return tabulate.tabulate([self], tablefmt=\"plain\") def __str__(self): return f\"{self}\" def __getitem__(self, item): return self._formatted_values[item] Methods download def download ( self , output_path = None , output_name = None ) Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). View Source def download(self, output_path=None, output_name=None): \"\"\" Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). \"\"\" log = requests.get(self.download_path).content if output_path is None: output_path = \"./\" if output_name is None: output_name = self.name with open(f\"{output_path}{output_name}\", \"wb\") as f: f.write(log) Logs class Logs ( ip = '192.168.1.101' , auto_download_index = True ) This class is an index of the log files stored on the drone To show the available logs you simply print this object, ie. if your Pioneer object is called p , you can do: print(p.logs) This will print a list of all available logs, with some of their metadata, such as name and maxdepth. You can access logfile objects either by index or by name. Eg. if you want the first logfile in the list you can do p.logs[0] , or if you want some particular log you can do p.logs[\"exampleName0001.csv\"] . You can even give it a slice, so if you want the last 10 logs you can do p.logs[:-10] . View Source class Logs: \"\"\"This class is an index of the log files stored on the drone To show the available logs you simply print this object, ie. if your Pioneer object is called `p`, you can do: ``` print(p.logs) ``` This will print a list of all available logs, with some of their metadata, such as name and maxdepth. You can access logfile objects either by index or by name. Eg. if you want the first logfile in the list you can do `p.logs[0]`, or if you want some particular log you can do `p.logs[\"exampleName0001.csv\"]`. You can even give it a slice, so if you want the last 10 logs you can do `p.logs[:-10]`. \"\"\" def __init__(self, ip=\"192.168.1.101\", auto_download_index=True): self.ip = ip if auto_download_index: self.refresh_log_index() else: self._logs = {} def _get_list_of_logs_from_drone(self): list_of_dictionaries = requests.get(\"http://\" + self.ip + \"/logcsv\").json() return list_of_dictionaries def _build_log_files_from_dictionary(self, list_of_logs_in_dictionaries): loglist = {} for log in list_of_logs_in_dictionaries: loglist[log[\"name\"]] = LogFile( log[\"maxdepth\"], log[\"name\"], log[\"timestamp\"], log[\"binsize\"], self.ip ) return loglist def refresh_log_index(self): \"\"\"Refresh the log index from the drone This is method is run on instantiation by default, but if you would like to check for new log files it can be called at any time. \"\"\" list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone() self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries) def __getitem__(self, item): if type(item) == str: try: return self._logs[item] except KeyError: raise KeyError(f\"A log with the name '{item}' does not exist\") else: try: return list(self._logs.values())[item] except IndexError: raise IndexError( f\"Tried to access log nr {item}, \" + f\"but there are only {len(self._logs.values())} logs available\" ) def __str__(self): return tabulate.tabulate( self, headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" ) Methods refresh_log_index def refresh_log_index ( self ) Refresh the log index from the drone This is method is run on instantiation by default, but if you would like to check for new log files it can be called at any time. View Source def refresh_log_index(self): \"\"\"Refresh the log index from the drone This is method is run on instantiation by default, but if you would like to check for new log files it can be called at any time. \"\"\" list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone() self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries)","title":"Logs"},{"location":"reference/blueye/sdk/logs/#module-blueyesdklogs","text":"View Source from datetime import datetime import requests import tabulate class LogFile: \"\"\" This class is a container for a log file stored on the drone The drone lists the file name, max depth, start time, and file size for each log, and you can show this information by printing the log object, eg. on a Pioneer object called `p`: ``` print(p.logs[0]) ``` or, if you want to display the header you can format the object with `with_header`: ``` print(f\"{p.logs[0]:with_header}\") ``` Calling the download() method on a log object will pull the CSV (Comma Separated Value) file from the drone to your local filesystem. \"\"\" def __init__(self, maxdepth, name, timestamp, binsize, ip): self.maxdepth = maxdepth self.name = name self.timestamp = datetime.fromisoformat(timestamp) self.binsize = binsize self.download_path = \"http://\" + ip + \"/logcsv/\" + name self._formatted_values = [ self.name, self.timestamp.strftime(\"%d. %b %Y %H:%M\"), f\"{self.maxdepth/1000:.2f} m\", self._human_readable_filesize(), ] def _human_readable_filesize(self): suffix = \"B\" num = self.binsize for unit in [\"\", \"Ki\", \"Mi\"]: if abs(num) < 1024.0: return f\"{num:3.1f} {unit}{suffix}\" num /= 1024.0 return f\"{num:.1f} Gi{suffix}\" def download(self, output_path=None, output_name=None): \"\"\" Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). \"\"\" log = requests.get(self.download_path).content if output_path is None: output_path = \"./\" if output_name is None: output_name = self.name with open(f\"{output_path}{output_name}\", \"wb\") as f: f.write(log) def __format__(self, format_specifier): if format_specifier == \"with_header\": return tabulate.tabulate( [self], headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" ) else: return tabulate.tabulate([self], tablefmt=\"plain\") def __str__(self): return f\"{self}\" def __getitem__(self, item): return self._formatted_values[item] class Logs: \"\"\"This class is an index of the log files stored on the drone To show the available logs you simply print this object, ie. if your Pioneer object is called `p`, you can do: ``` print(p.logs) ``` This will print a list of all available logs, with some of their metadata, such as name and maxdepth. You can access logfile objects either by index or by name. Eg. if you want the first logfile in the list you can do `p.logs[0]`, or if you want some particular log you can do `p.logs[\"exampleName0001.csv\"]`. You can even give it a slice, so if you want the last 10 logs you can do `p.logs[:-10]`. \"\"\" def __init__(self, ip=\"192.168.1.101\", auto_download_index=True): self.ip = ip if auto_download_index: self.refresh_log_index() else: self._logs = {} def _get_list_of_logs_from_drone(self): list_of_dictionaries = requests.get(\"http://\" + self.ip + \"/logcsv\").json() return list_of_dictionaries def _build_log_files_from_dictionary(self, list_of_logs_in_dictionaries): loglist = {} for log in list_of_logs_in_dictionaries: loglist[log[\"name\"]] = LogFile( log[\"maxdepth\"], log[\"name\"], log[\"timestamp\"], log[\"binsize\"], self.ip ) return loglist def refresh_log_index(self): \"\"\"Refresh the log index from the drone This is method is run on instantiation by default, but if you would like to check for new log files it can be called at any time. \"\"\" list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone() self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries) def __getitem__(self, item): if type(item) == str: try: return self._logs[item] except KeyError: raise KeyError(f\"A log with the name '{item}' does not exist\") else: try: return list(self._logs.values())[item] except IndexError: raise IndexError( f\"Tried to access log nr {item}, \" + f\"but there are only {len(self._logs.values())} logs available\" ) def __str__(self): return tabulate.tabulate( self, headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" )","title":"Module blueye.sdk.logs"},{"location":"reference/blueye/sdk/logs/#classes","text":"","title":"Classes"},{"location":"reference/blueye/sdk/logs/#logfile","text":"class LogFile ( maxdepth , name , timestamp , binsize , ip ) This class is a container for a log file stored on the drone The drone lists the file name, max depth, start time, and file size for each log, and you can show this information by printing the log object, eg. on a Pioneer object called p : print(p.logs[0]) or, if you want to display the header you can format the object with with_header : print(f\"{p.logs[0]:with_header}\") Calling the download() method on a log object will pull the CSV (Comma Separated Value) file from the drone to your local filesystem. View Source class LogFile: \"\"\" This class is a container for a log file stored on the drone The drone lists the file name, max depth, start time, and file size for each log, and you can show this information by printing the log object, eg. on a Pioneer object called `p`: ``` print(p.logs[0]) ``` or, if you want to display the header you can format the object with `with_header`: ``` print(f\"{p.logs[0]:with_header}\") ``` Calling the download() method on a log object will pull the CSV (Comma Separated Value) file from the drone to your local filesystem. \"\"\" def __init__(self, maxdepth, name, timestamp, binsize, ip): self.maxdepth = maxdepth self.name = name self.timestamp = datetime.fromisoformat(timestamp) self.binsize = binsize self.download_path = \"http://\" + ip + \"/logcsv/\" + name self._formatted_values = [ self.name, self.timestamp.strftime(\"%d. %b %Y %H:%M\"), f\"{self.maxdepth/1000:.2f} m\", self._human_readable_filesize(), ] def _human_readable_filesize(self): suffix = \"B\" num = self.binsize for unit in [\"\", \"Ki\", \"Mi\"]: if abs(num) < 1024.0: return f\"{num:3.1f} {unit}{suffix}\" num /= 1024.0 return f\"{num:.1f} Gi{suffix}\" def download(self, output_path=None, output_name=None): \"\"\" Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). \"\"\" log = requests.get(self.download_path).content if output_path is None: output_path = \"./\" if output_name is None: output_name = self.name with open(f\"{output_path}{output_name}\", \"wb\") as f: f.write(log) def __format__(self, format_specifier): if format_specifier == \"with_header\": return tabulate.tabulate( [self], headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" ) else: return tabulate.tabulate([self], tablefmt=\"plain\") def __str__(self): return f\"{self}\" def __getitem__(self, item): return self._formatted_values[item]","title":"LogFile"},{"location":"reference/blueye/sdk/logs/#methods","text":"","title":"Methods"},{"location":"reference/blueye/sdk/logs/#download","text":"def download ( self , output_path = None , output_name = None ) Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). View Source def download(self, output_path=None, output_name=None): \"\"\" Download the specified log to your local file system If you specify an output_path the log file will be downloaded to that directory instead of the current one. Specifying output_name will overwrite the default file name with whatever you have specified (be sure to include the .csv extension). \"\"\" log = requests.get(self.download_path).content if output_path is None: output_path = \"./\" if output_name is None: output_name = self.name with open(f\"{output_path}{output_name}\", \"wb\") as f: f.write(log)","title":"download"},{"location":"reference/blueye/sdk/logs/#logs","text":"class Logs ( ip = '192.168.1.101' , auto_download_index = True ) This class is an index of the log files stored on the drone To show the available logs you simply print this object, ie. if your Pioneer object is called p , you can do: print(p.logs) This will print a list of all available logs, with some of their metadata, such as name and maxdepth. You can access logfile objects either by index or by name. Eg. if you want the first logfile in the list you can do p.logs[0] , or if you want some particular log you can do p.logs[\"exampleName0001.csv\"] . You can even give it a slice, so if you want the last 10 logs you can do p.logs[:-10] . View Source class Logs: \"\"\"This class is an index of the log files stored on the drone To show the available logs you simply print this object, ie. if your Pioneer object is called `p`, you can do: ``` print(p.logs) ``` This will print a list of all available logs, with some of their metadata, such as name and maxdepth. You can access logfile objects either by index or by name. Eg. if you want the first logfile in the list you can do `p.logs[0]`, or if you want some particular log you can do `p.logs[\"exampleName0001.csv\"]`. You can even give it a slice, so if you want the last 10 logs you can do `p.logs[:-10]`. \"\"\" def __init__(self, ip=\"192.168.1.101\", auto_download_index=True): self.ip = ip if auto_download_index: self.refresh_log_index() else: self._logs = {} def _get_list_of_logs_from_drone(self): list_of_dictionaries = requests.get(\"http://\" + self.ip + \"/logcsv\").json() return list_of_dictionaries def _build_log_files_from_dictionary(self, list_of_logs_in_dictionaries): loglist = {} for log in list_of_logs_in_dictionaries: loglist[log[\"name\"]] = LogFile( log[\"maxdepth\"], log[\"name\"], log[\"timestamp\"], log[\"binsize\"], self.ip ) return loglist def refresh_log_index(self): \"\"\"Refresh the log index from the drone This is method is run on instantiation by default, but if you would like to check for new log files it can be called at any time. \"\"\" list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone() self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries) def __getitem__(self, item): if type(item) == str: try: return self._logs[item] except KeyError: raise KeyError(f\"A log with the name '{item}' does not exist\") else: try: return list(self._logs.values())[item] except IndexError: raise IndexError( f\"Tried to access log nr {item}, \" + f\"but there are only {len(self._logs.values())} logs available\" ) def __str__(self): return tabulate.tabulate( self, headers=[\"Name\", \"Time\", \"Max depth\", \"Size\"], tablefmt=\"plain\" )","title":"Logs"},{"location":"reference/blueye/sdk/logs/#methods_1","text":"","title":"Methods"},{"location":"reference/blueye/sdk/logs/#refresh_log_index","text":"def refresh_log_index ( self ) Refresh the log index from the drone This is method is run on instantiation by default, but if you would like to check for new log files it can be called at any time. View Source def refresh_log_index(self): \"\"\"Refresh the log index from the drone This is method is run on instantiation by default, but if you would like to check for new log files it can be called at any time. \"\"\" list_of_logs_in_dictionaries = self._get_list_of_logs_from_drone() self._logs = self._build_log_files_from_dictionary(list_of_logs_in_dictionaries)","title":"refresh_log_index"},{"location":"reference/blueye/sdk/motion/","text":"Module blueye.sdk.motion View Source class Motion: \"\"\"Control the motion of the Pioneer, and set automatic control modes Motion can be set one degree of freedom at a time by using the 4 motion properties (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the `send_thruster_setpoint` method. The current thruster setpoint state is stored in the `current_thruster_setpoints` variable, this is done because the Pioneer does not report back its current thruster setpoint. \"\"\" def __init__(self, _tcp_client, _state_watcher): self._tcp_client = _tcp_client self._state_watcher = _state_watcher self.current_thruster_setpoints = {\"surge\": 0, \"sway\": 0, \"heave\": 0, \"yaw\": 0} @property def surge(self) -> float: \"\"\" Set force reference for the surge direction Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward \"\"\" return self.current_thruster_setpoints[\"surge\"] @surge.setter def surge(self, surge_value: float): self.current_thruster_setpoints[\"surge\"] = surge_value self.update_setpoint() @property def sway(self) -> float: \"\"\" Set force reference for the sway direction Arguments: * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right \"\"\" return self.current_thruster_setpoints[\"sway\"] @sway.setter def sway(self, sway_value: float): self.current_thruster_setpoints[\"sway\"] = sway_value self.update_setpoint() @property def heave(self) -> float: \"\"\" Set force reference for the heave direction Arguments: * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move downwards \"\"\" return self.current_thruster_setpoints[\"heave\"] @heave.setter def heave(self, heave_value: float): self.current_thruster_setpoints[\"heave\"] = heave_value self.update_setpoint() @property def yaw(self) -> float: \"\"\" Set force reference for the yaw direction Arguments: * **yaw** (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" return self.current_thruster_setpoints[\"yaw\"] @yaw.setter def yaw(self, yaw_value: float): self.current_thruster_setpoints[\"yaw\"] = yaw_value self.update_setpoint() def update_setpoint(self): self.send_thruster_setpoint(*self.current_thruster_setpoints.values()) def send_thruster_setpoint(self, surge, sway, heave, yaw): \"\"\"Control the thrusters of the pioneer Set reference values between -1 and 1 for each controllable degree of freedom on the Pioneer. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. * **yaw** (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" self.current_thruster_setpoints[\"surge\"] = surge self.current_thruster_setpoints[\"sway\"] = sway self.current_thruster_setpoints[\"heave\"] = heave self.current_thruster_setpoints[\"yaw\"] = yaw self._tcp_client.motion_input(surge, sway, heave, yaw, 0, 0) @property def auto_depth_active(self) -> bool: \"\"\"Enable or disable the auto depth control mode When auto depth is active, input for the heave direction to the thruster_setpoint function specifies a speed set point instead of a force set point. A control loop on the Pioneer will then attempt to maintain the wanted speed in the heave direction as long as auto depth is active. *Arguments*: * active (bool): Activate auto depth mode if active is true, de-activate if false *Returns*: * active (bool): Returns true if auto depth is active, false if it is not active \"\"\" AUTO_DEPTH_MODE = 3 AUTO_HEADING_AND_AUTO_DEPTH_MODE = 9 state = self._state_watcher.general_state if ( state[\"control_mode\"] is AUTO_DEPTH_MODE or state[\"control_mode\"] is AUTO_HEADING_AND_AUTO_DEPTH_MODE ): return True else: return False @auto_depth_active.setter def auto_depth_active(self, active: bool): if active: self._tcp_client.auto_depth_on() else: self._tcp_client.auto_depth_off() @property def auto_heading_active(self) -> bool: \"\"\"Enable or disable the auto heading control mode When auto heading is active, input for the yaw direction to the thruster_setpoint function specifies a angular speed set point instead of a moment set point. A control loop on the Pioneer will then attempt to maintain the wanted angular velocity in the yaw direction as long as auto heading is active. *Arguments*: * active (bool): Activate auto heading mode if active is true, de-activate if false *Returns*: * active (bool): Returns true if auto heading mode is active, false if it is not active \"\"\" AUTO_HEADING_MODE = 7 AUTO_HEADING_AND_AUTO_DEPTH_MODE = 9 state = self._state_watcher.general_state if ( state[\"control_mode\"] is AUTO_HEADING_MODE or state[\"control_mode\"] is AUTO_HEADING_AND_AUTO_DEPTH_MODE ): return True else: return False @auto_heading_active.setter def auto_heading_active(self, active: bool): if active: self._tcp_client.auto_heading_on() else: self._tcp_client.auto_heading_off() Classes Motion class Motion ( _tcp_client , _state_watcher ) Control the motion of the Pioneer, and set automatic control modes Motion can be set one degree of freedom at a time by using the 4 motion properties (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the send_thruster_setpoint method. The current thruster setpoint state is stored in the current_thruster_setpoints variable, this is done because the Pioneer does not report back its current thruster setpoint. View Source class Motion: \"\"\"Control the motion of the Pioneer, and set automatic control modes Motion can be set one degree of freedom at a time by using the 4 motion properties (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the `send_thruster_setpoint` method. The current thruster setpoint state is stored in the `current_thruster_setpoints` variable, this is done because the Pioneer does not report back its current thruster setpoint. \"\"\" def __init__(self, _tcp_client, _state_watcher): self._tcp_client = _tcp_client self._state_watcher = _state_watcher self.current_thruster_setpoints = {\"surge\": 0, \"sway\": 0, \"heave\": 0, \"yaw\": 0} @property def surge(self) -> float: \"\"\" Set force reference for the surge direction Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward \"\"\" return self.current_thruster_setpoints[\"surge\"] @surge.setter def surge(self, surge_value: float): self.current_thruster_setpoints[\"surge\"] = surge_value self.update_setpoint() @property def sway(self) -> float: \"\"\" Set force reference for the sway direction Arguments: * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right \"\"\" return self.current_thruster_setpoints[\"sway\"] @sway.setter def sway(self, sway_value: float): self.current_thruster_setpoints[\"sway\"] = sway_value self.update_setpoint() @property def heave(self) -> float: \"\"\" Set force reference for the heave direction Arguments: * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move downwards \"\"\" return self.current_thruster_setpoints[\"heave\"] @heave.setter def heave(self, heave_value: float): self.current_thruster_setpoints[\"heave\"] = heave_value self.update_setpoint() @property def yaw(self) -> float: \"\"\" Set force reference for the yaw direction Arguments: * **yaw** (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" return self.current_thruster_setpoints[\"yaw\"] @yaw.setter def yaw(self, yaw_value: float): self.current_thruster_setpoints[\"yaw\"] = yaw_value self.update_setpoint() def update_setpoint(self): self.send_thruster_setpoint(*self.current_thruster_setpoints.values()) def send_thruster_setpoint(self, surge, sway, heave, yaw): \"\"\"Control the thrusters of the pioneer Set reference values between -1 and 1 for each controllable degree of freedom on the Pioneer. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. * **yaw** (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" self.current_thruster_setpoints[\"surge\"] = surge self.current_thruster_setpoints[\"sway\"] = sway self.current_thruster_setpoints[\"heave\"] = heave self.current_thruster_setpoints[\"yaw\"] = yaw self._tcp_client.motion_input(surge, sway, heave, yaw, 0, 0) @property def auto_depth_active(self) -> bool: \"\"\"Enable or disable the auto depth control mode When auto depth is active, input for the heave direction to the thruster_setpoint function specifies a speed set point instead of a force set point. A control loop on the Pioneer will then attempt to maintain the wanted speed in the heave direction as long as auto depth is active. *Arguments*: * active (bool): Activate auto depth mode if active is true, de-activate if false *Returns*: * active (bool): Returns true if auto depth is active, false if it is not active \"\"\" AUTO_DEPTH_MODE = 3 AUTO_HEADING_AND_AUTO_DEPTH_MODE = 9 state = self._state_watcher.general_state if ( state[\"control_mode\"] is AUTO_DEPTH_MODE or state[\"control_mode\"] is AUTO_HEADING_AND_AUTO_DEPTH_MODE ): return True else: return False @auto_depth_active.setter def auto_depth_active(self, active: bool): if active: self._tcp_client.auto_depth_on() else: self._tcp_client.auto_depth_off() @property def auto_heading_active(self) -> bool: \"\"\"Enable or disable the auto heading control mode When auto heading is active, input for the yaw direction to the thruster_setpoint function specifies a angular speed set point instead of a moment set point. A control loop on the Pioneer will then attempt to maintain the wanted angular velocity in the yaw direction as long as auto heading is active. *Arguments*: * active (bool): Activate auto heading mode if active is true, de-activate if false *Returns*: * active (bool): Returns true if auto heading mode is active, false if it is not active \"\"\" AUTO_HEADING_MODE = 7 AUTO_HEADING_AND_AUTO_DEPTH_MODE = 9 state = self._state_watcher.general_state if ( state[\"control_mode\"] is AUTO_HEADING_MODE or state[\"control_mode\"] is AUTO_HEADING_AND_AUTO_DEPTH_MODE ): return True else: return False @auto_heading_active.setter def auto_heading_active(self, active: bool): if active: self._tcp_client.auto_heading_on() else: self._tcp_client.auto_heading_off() Instance variables auto_depth_active Enable or disable the auto depth control mode When auto depth is active, input for the heave direction to the thruster_setpoint function specifies a speed set point instead of a force set point. A control loop on the Pioneer will then attempt to maintain the wanted speed in the heave direction as long as auto depth is active. Arguments : active (bool): Activate auto depth mode if active is true, de-activate if false Returns : active (bool): Returns true if auto depth is active, false if it is not active auto_heading_active Enable or disable the auto heading control mode When auto heading is active, input for the yaw direction to the thruster_setpoint function specifies a angular speed set point instead of a moment set point. A control loop on the Pioneer will then attempt to maintain the wanted angular velocity in the yaw direction as long as auto heading is active. Arguments : active (bool): Activate auto heading mode if active is true, de-activate if false Returns : active (bool): Returns true if auto heading mode is active, false if it is not active heave Set force reference for the heave direction Arguments: heave (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move downwards surge Set force reference for the surge direction Arguments: surge (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward sway Set force reference for the sway direction Arguments: sway (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right yaw Set force reference for the yaw direction Arguments: yaw (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. Methods send_thruster_setpoint def send_thruster_setpoint ( self , surge , sway , heave , yaw ) Control the thrusters of the pioneer Set reference values between -1 and 1 for each controllable degree of freedom on the Pioneer. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: surge (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward sway (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right heave (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. yaw (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. View Source def send_thruster_setpoint(self, surge, sway, heave, yaw): \"\"\"Control the thrusters of the pioneer Set reference values between -1 and 1 for each controllable degree of freedom on the Pioneer. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. * **yaw** (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" self.current_thruster_setpoints[\"surge\"] = surge self.current_thruster_setpoints[\"sway\"] = sway self.current_thruster_setpoints[\"heave\"] = heave self.current_thruster_setpoints[\"yaw\"] = yaw self._tcp_client.motion_input(surge, sway, heave, yaw, 0, 0) update_setpoint def update_setpoint ( self ) View Source def update_setpoint(self): self.send_thruster_setpoint(*self.current_thruster_setpoints.values())","title":"Motion"},{"location":"reference/blueye/sdk/motion/#module-blueyesdkmotion","text":"View Source class Motion: \"\"\"Control the motion of the Pioneer, and set automatic control modes Motion can be set one degree of freedom at a time by using the 4 motion properties (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the `send_thruster_setpoint` method. The current thruster setpoint state is stored in the `current_thruster_setpoints` variable, this is done because the Pioneer does not report back its current thruster setpoint. \"\"\" def __init__(self, _tcp_client, _state_watcher): self._tcp_client = _tcp_client self._state_watcher = _state_watcher self.current_thruster_setpoints = {\"surge\": 0, \"sway\": 0, \"heave\": 0, \"yaw\": 0} @property def surge(self) -> float: \"\"\" Set force reference for the surge direction Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward \"\"\" return self.current_thruster_setpoints[\"surge\"] @surge.setter def surge(self, surge_value: float): self.current_thruster_setpoints[\"surge\"] = surge_value self.update_setpoint() @property def sway(self) -> float: \"\"\" Set force reference for the sway direction Arguments: * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right \"\"\" return self.current_thruster_setpoints[\"sway\"] @sway.setter def sway(self, sway_value: float): self.current_thruster_setpoints[\"sway\"] = sway_value self.update_setpoint() @property def heave(self) -> float: \"\"\" Set force reference for the heave direction Arguments: * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move downwards \"\"\" return self.current_thruster_setpoints[\"heave\"] @heave.setter def heave(self, heave_value: float): self.current_thruster_setpoints[\"heave\"] = heave_value self.update_setpoint() @property def yaw(self) -> float: \"\"\" Set force reference for the yaw direction Arguments: * **yaw** (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" return self.current_thruster_setpoints[\"yaw\"] @yaw.setter def yaw(self, yaw_value: float): self.current_thruster_setpoints[\"yaw\"] = yaw_value self.update_setpoint() def update_setpoint(self): self.send_thruster_setpoint(*self.current_thruster_setpoints.values()) def send_thruster_setpoint(self, surge, sway, heave, yaw): \"\"\"Control the thrusters of the pioneer Set reference values between -1 and 1 for each controllable degree of freedom on the Pioneer. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. * **yaw** (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" self.current_thruster_setpoints[\"surge\"] = surge self.current_thruster_setpoints[\"sway\"] = sway self.current_thruster_setpoints[\"heave\"] = heave self.current_thruster_setpoints[\"yaw\"] = yaw self._tcp_client.motion_input(surge, sway, heave, yaw, 0, 0) @property def auto_depth_active(self) -> bool: \"\"\"Enable or disable the auto depth control mode When auto depth is active, input for the heave direction to the thruster_setpoint function specifies a speed set point instead of a force set point. A control loop on the Pioneer will then attempt to maintain the wanted speed in the heave direction as long as auto depth is active. *Arguments*: * active (bool): Activate auto depth mode if active is true, de-activate if false *Returns*: * active (bool): Returns true if auto depth is active, false if it is not active \"\"\" AUTO_DEPTH_MODE = 3 AUTO_HEADING_AND_AUTO_DEPTH_MODE = 9 state = self._state_watcher.general_state if ( state[\"control_mode\"] is AUTO_DEPTH_MODE or state[\"control_mode\"] is AUTO_HEADING_AND_AUTO_DEPTH_MODE ): return True else: return False @auto_depth_active.setter def auto_depth_active(self, active: bool): if active: self._tcp_client.auto_depth_on() else: self._tcp_client.auto_depth_off() @property def auto_heading_active(self) -> bool: \"\"\"Enable or disable the auto heading control mode When auto heading is active, input for the yaw direction to the thruster_setpoint function specifies a angular speed set point instead of a moment set point. A control loop on the Pioneer will then attempt to maintain the wanted angular velocity in the yaw direction as long as auto heading is active. *Arguments*: * active (bool): Activate auto heading mode if active is true, de-activate if false *Returns*: * active (bool): Returns true if auto heading mode is active, false if it is not active \"\"\" AUTO_HEADING_MODE = 7 AUTO_HEADING_AND_AUTO_DEPTH_MODE = 9 state = self._state_watcher.general_state if ( state[\"control_mode\"] is AUTO_HEADING_MODE or state[\"control_mode\"] is AUTO_HEADING_AND_AUTO_DEPTH_MODE ): return True else: return False @auto_heading_active.setter def auto_heading_active(self, active: bool): if active: self._tcp_client.auto_heading_on() else: self._tcp_client.auto_heading_off()","title":"Module blueye.sdk.motion"},{"location":"reference/blueye/sdk/motion/#classes","text":"","title":"Classes"},{"location":"reference/blueye/sdk/motion/#motion","text":"class Motion ( _tcp_client , _state_watcher ) Control the motion of the Pioneer, and set automatic control modes Motion can be set one degree of freedom at a time by using the 4 motion properties (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the send_thruster_setpoint method. The current thruster setpoint state is stored in the current_thruster_setpoints variable, this is done because the Pioneer does not report back its current thruster setpoint. View Source class Motion: \"\"\"Control the motion of the Pioneer, and set automatic control modes Motion can be set one degree of freedom at a time by using the 4 motion properties (surge, sway, heave and yaw) or for all 4 degrees of freedom in one go through the `send_thruster_setpoint` method. The current thruster setpoint state is stored in the `current_thruster_setpoints` variable, this is done because the Pioneer does not report back its current thruster setpoint. \"\"\" def __init__(self, _tcp_client, _state_watcher): self._tcp_client = _tcp_client self._state_watcher = _state_watcher self.current_thruster_setpoints = {\"surge\": 0, \"sway\": 0, \"heave\": 0, \"yaw\": 0} @property def surge(self) -> float: \"\"\" Set force reference for the surge direction Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward \"\"\" return self.current_thruster_setpoints[\"surge\"] @surge.setter def surge(self, surge_value: float): self.current_thruster_setpoints[\"surge\"] = surge_value self.update_setpoint() @property def sway(self) -> float: \"\"\" Set force reference for the sway direction Arguments: * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right \"\"\" return self.current_thruster_setpoints[\"sway\"] @sway.setter def sway(self, sway_value: float): self.current_thruster_setpoints[\"sway\"] = sway_value self.update_setpoint() @property def heave(self) -> float: \"\"\" Set force reference for the heave direction Arguments: * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move downwards \"\"\" return self.current_thruster_setpoints[\"heave\"] @heave.setter def heave(self, heave_value: float): self.current_thruster_setpoints[\"heave\"] = heave_value self.update_setpoint() @property def yaw(self) -> float: \"\"\" Set force reference for the yaw direction Arguments: * **yaw** (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" return self.current_thruster_setpoints[\"yaw\"] @yaw.setter def yaw(self, yaw_value: float): self.current_thruster_setpoints[\"yaw\"] = yaw_value self.update_setpoint() def update_setpoint(self): self.send_thruster_setpoint(*self.current_thruster_setpoints.values()) def send_thruster_setpoint(self, surge, sway, heave, yaw): \"\"\"Control the thrusters of the pioneer Set reference values between -1 and 1 for each controllable degree of freedom on the Pioneer. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. * **yaw** (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" self.current_thruster_setpoints[\"surge\"] = surge self.current_thruster_setpoints[\"sway\"] = sway self.current_thruster_setpoints[\"heave\"] = heave self.current_thruster_setpoints[\"yaw\"] = yaw self._tcp_client.motion_input(surge, sway, heave, yaw, 0, 0) @property def auto_depth_active(self) -> bool: \"\"\"Enable or disable the auto depth control mode When auto depth is active, input for the heave direction to the thruster_setpoint function specifies a speed set point instead of a force set point. A control loop on the Pioneer will then attempt to maintain the wanted speed in the heave direction as long as auto depth is active. *Arguments*: * active (bool): Activate auto depth mode if active is true, de-activate if false *Returns*: * active (bool): Returns true if auto depth is active, false if it is not active \"\"\" AUTO_DEPTH_MODE = 3 AUTO_HEADING_AND_AUTO_DEPTH_MODE = 9 state = self._state_watcher.general_state if ( state[\"control_mode\"] is AUTO_DEPTH_MODE or state[\"control_mode\"] is AUTO_HEADING_AND_AUTO_DEPTH_MODE ): return True else: return False @auto_depth_active.setter def auto_depth_active(self, active: bool): if active: self._tcp_client.auto_depth_on() else: self._tcp_client.auto_depth_off() @property def auto_heading_active(self) -> bool: \"\"\"Enable or disable the auto heading control mode When auto heading is active, input for the yaw direction to the thruster_setpoint function specifies a angular speed set point instead of a moment set point. A control loop on the Pioneer will then attempt to maintain the wanted angular velocity in the yaw direction as long as auto heading is active. *Arguments*: * active (bool): Activate auto heading mode if active is true, de-activate if false *Returns*: * active (bool): Returns true if auto heading mode is active, false if it is not active \"\"\" AUTO_HEADING_MODE = 7 AUTO_HEADING_AND_AUTO_DEPTH_MODE = 9 state = self._state_watcher.general_state if ( state[\"control_mode\"] is AUTO_HEADING_MODE or state[\"control_mode\"] is AUTO_HEADING_AND_AUTO_DEPTH_MODE ): return True else: return False @auto_heading_active.setter def auto_heading_active(self, active: bool): if active: self._tcp_client.auto_heading_on() else: self._tcp_client.auto_heading_off()","title":"Motion"},{"location":"reference/blueye/sdk/motion/#instance-variables","text":"auto_depth_active Enable or disable the auto depth control mode When auto depth is active, input for the heave direction to the thruster_setpoint function specifies a speed set point instead of a force set point. A control loop on the Pioneer will then attempt to maintain the wanted speed in the heave direction as long as auto depth is active. Arguments : active (bool): Activate auto depth mode if active is true, de-activate if false Returns : active (bool): Returns true if auto depth is active, false if it is not active auto_heading_active Enable or disable the auto heading control mode When auto heading is active, input for the yaw direction to the thruster_setpoint function specifies a angular speed set point instead of a moment set point. A control loop on the Pioneer will then attempt to maintain the wanted angular velocity in the yaw direction as long as auto heading is active. Arguments : active (bool): Activate auto heading mode if active is true, de-activate if false Returns : active (bool): Returns true if auto heading mode is active, false if it is not active heave Set force reference for the heave direction Arguments: heave (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move downwards surge Set force reference for the surge direction Arguments: surge (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward sway Set force reference for the sway direction Arguments: sway (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right yaw Set force reference for the yaw direction Arguments: yaw (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise.","title":"Instance variables"},{"location":"reference/blueye/sdk/motion/#methods","text":"","title":"Methods"},{"location":"reference/blueye/sdk/motion/#send_thruster_setpoint","text":"def send_thruster_setpoint ( self , surge , sway , heave , yaw ) Control the thrusters of the pioneer Set reference values between -1 and 1 for each controllable degree of freedom on the Pioneer. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: surge (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward sway (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right heave (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. yaw (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. View Source def send_thruster_setpoint(self, surge, sway, heave, yaw): \"\"\"Control the thrusters of the pioneer Set reference values between -1 and 1 for each controllable degree of freedom on the Pioneer. The reference values are mapped linearly to a thruster force, a set point of -1 correspons to maximum negative force and a set point of 1 corresponds to maximum positive force. For the yaw direction the reference is a moment not a force, as the yaw direction is rotational not translational. Arguments: * **surge** (float): Force set point in the surge direction in range <-1, 1>, a positive set point makes the drone move forward * **sway** (float): Force set point in the sway direction in range <-1, 1>, a positive set point makes the drone move to the right * **heave** (float): Force set point in the heave direction in range <-1, 1>, a positive set point makes the drone move down. * **yaw** (float): Moment set point in the sway direction in range <-1, 1>, a positive set point makes the drone rotate clockwise. \"\"\" self.current_thruster_setpoints[\"surge\"] = surge self.current_thruster_setpoints[\"sway\"] = sway self.current_thruster_setpoints[\"heave\"] = heave self.current_thruster_setpoints[\"yaw\"] = yaw self._tcp_client.motion_input(surge, sway, heave, yaw, 0, 0)","title":"send_thruster_setpoint"},{"location":"reference/blueye/sdk/motion/#update_setpoint","text":"def update_setpoint ( self ) View Source def update_setpoint(self): self.send_thruster_setpoint(*self.current_thruster_setpoints.values())","title":"update_setpoint"},{"location":"reference/blueye/sdk/pioneer/","text":"Module blueye.sdk.pioneer View Source #!/usr/bin/env python3 import threading import time import warnings from blueye.protocol import TcpClient, UdpClient from blueye.protocol.exceptions import ResponseTimeout from .camera import Camera from .motion import Motion from .logs import Logs class _PioneerStateWatcher(threading.Thread): \"\"\"Subscribes to UDP messages from the drone and stores the latest data \"\"\" def __init__(self): threading.Thread.__init__(self) self._general_state = None self._calibration_state = None self._udpclient = UdpClient() self._exit_flag = threading.Event() self.daemon = True @property def general_state(self) -> dict: start = time.time() while self._general_state is None: if time.time() - start > 3: raise TimeoutError(\"No state message received from drone\") return self._general_state @property def calibration_state(self) -> dict: start = time.time() while self._calibration_state is None: if time.time() - start > 3: raise TimeoutError(\"No state message received from drone\") return self._calibration_state def run(self): while not self._exit_flag.is_set(): data_packet = self._udpclient.get_data_dict() if data_packet[\"command_type\"] == 1: self._general_state = data_packet elif data_packet[\"command_type\"] == 2: self._calibration_state = data_packet def stop(self): self._exit_flag.set() class SlaveModeWarning(UserWarning): \"\"\"Raised when trying to perform action not possible in slave mode\"\"\" class slaveTcpClient: \"\"\"A dummy TCP client that warns you if you use any of its functions\"\"\" def __getattr__(self, name): def method(*args): warnings.warn( f\"Unable to call {name}{args} with client in slave mode\", SlaveModeWarning, stacklevel=2, ) return method class Pioneer: \"\"\"A class providing a interface to the Blueye pioneer's basic functions Automatically connects to the drone using the default ip and port when instantiated, this behaviour can be disabled by setting `autoConnect=False`. The drone only supports one client controlling it at a time, but if you pass `slaveModeEnabled=True` you will still be able to receive data from the drone. \"\"\" def __init__( self, ip=\"192.168.1.101\", tcpPort=2011, autoConnect=True, slaveModeEnabled=False ): self._ip = ip self._slaveModeEnabled = slaveModeEnabled if slaveModeEnabled: self._tcp_client = slaveTcpClient() else: self._tcp_client = TcpClient(ip=ip, port=tcpPort, autoConnect=autoConnect) self._state_watcher = _PioneerStateWatcher() self.camera = Camera(self._tcp_client, self._state_watcher) self.motion = Motion(self._tcp_client, self._state_watcher) self.logs = Logs(ip=ip, auto_download_index=autoConnect) if autoConnect is True: self.connect() def connect(self): \"\"\"Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. \"\"\" self._state_watcher.start() self.logs.refresh_log_index() if self._slaveModeEnabled is False: if self._tcp_client._sock is None and not self._tcp_client.isAlive(): self._tcp_client.connect() self._tcp_client.start() try: # Ensure that we are able to communicate with the drone self.ping() except ResponseTimeout as e: raise ConnectionError( f\"Found drone at {self._tcp_client._ip}:{self._tcp_client._port}, \" \"but was unable to establish communication with it. \" \"Is there another client connected?\" ) from e self.motion.update_setpoint() @property def lights(self) -> int: \"\"\"Get or set the brightness of the pioneers bottom canister lights *Arguments*: * brightness (int): Set the brightness of the bottom canister LED's in the range <0, 255> *Returns*: * brightness (int): The brightness of the bottom canister LED's in the range <0, 255> \"\"\" state = self._state_watcher.general_state return state[\"lights_upper\"] @lights.setter def lights(self, brightness: int): try: self._tcp_client.set_lights(brightness, 0) except ValueError as e: raise ValueError( \"Error occured while trying to set lights to: \" f\"{brightness}\" ) from e @property def depth(self) -> int: \"\"\"Get the current depth in millimeters *Returns*: * depth (int): The depth in millimeters of water column. \"\"\" return self._state_watcher.general_state[\"depth\"] @property def pose(self) -> dict: \"\"\"Get the current orientation of the drone *Returns*: * pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359. \"\"\" pose = { \"roll\": (self._state_watcher.general_state[\"roll\"] + 360) % 360, \"pitch\": (self._state_watcher.general_state[\"pitch\"] + 360) % 360, \"yaw\": (self._state_watcher.general_state[\"yaw\"] + 360) % 360, } return pose def ping(self): \"\"\"Ping drone, an exception is thrown by TcpClient if drone does not answer\"\"\" self._tcp_client.ping() Classes Pioneer class Pioneer ( ip = '192.168.1.101' , tcpPort = 2011 , autoConnect = True , slaveModeEnabled = False ) A class providing a interface to the Blueye pioneer's basic functions Automatically connects to the drone using the default ip and port when instantiated, this behaviour can be disabled by setting autoConnect=False . The drone only supports one client controlling it at a time, but if you pass slaveModeEnabled=True you will still be able to receive data from the drone. View Source class Pioneer: \"\"\"A class providing a interface to the Blueye pioneer's basic functions Automatically connects to the drone using the default ip and port when instantiated, this behaviour can be disabled by setting `autoConnect=False`. The drone only supports one client controlling it at a time, but if you pass `slaveModeEnabled=True` you will still be able to receive data from the drone. \"\"\" def __init__( self, ip=\"192.168.1.101\", tcpPort=2011, autoConnect=True, slaveModeEnabled=False ): self._ip = ip self._slaveModeEnabled = slaveModeEnabled if slaveModeEnabled: self._tcp_client = slaveTcpClient() else: self._tcp_client = TcpClient(ip=ip, port=tcpPort, autoConnect=autoConnect) self._state_watcher = _PioneerStateWatcher() self.camera = Camera(self._tcp_client, self._state_watcher) self.motion = Motion(self._tcp_client, self._state_watcher) self.logs = Logs(ip=ip, auto_download_index=autoConnect) if autoConnect is True: self.connect() def connect(self): \"\"\"Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. \"\"\" self._state_watcher.start() self.logs.refresh_log_index() if self._slaveModeEnabled is False: if self._tcp_client._sock is None and not self._tcp_client.isAlive(): self._tcp_client.connect() self._tcp_client.start() try: # Ensure that we are able to communicate with the drone self.ping() except ResponseTimeout as e: raise ConnectionError( f\"Found drone at {self._tcp_client._ip}:{self._tcp_client._port}, \" \"but was unable to establish communication with it. \" \"Is there another client connected?\" ) from e self.motion.update_setpoint() @property def lights(self) -> int: \"\"\"Get or set the brightness of the pioneers bottom canister lights *Arguments*: * brightness (int): Set the brightness of the bottom canister LED's in the range <0, 255> *Returns*: * brightness (int): The brightness of the bottom canister LED's in the range <0, 255> \"\"\" state = self._state_watcher.general_state return state[\"lights_upper\"] @lights.setter def lights(self, brightness: int): try: self._tcp_client.set_lights(brightness, 0) except ValueError as e: raise ValueError( \"Error occured while trying to set lights to: \" f\"{brightness}\" ) from e @property def depth(self) -> int: \"\"\"Get the current depth in millimeters *Returns*: * depth (int): The depth in millimeters of water column. \"\"\" return self._state_watcher.general_state[\"depth\"] @property def pose(self) -> dict: \"\"\"Get the current orientation of the drone *Returns*: * pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359. \"\"\" pose = { \"roll\": (self._state_watcher.general_state[\"roll\"] + 360) % 360, \"pitch\": (self._state_watcher.general_state[\"pitch\"] + 360) % 360, \"yaw\": (self._state_watcher.general_state[\"yaw\"] + 360) % 360, } return pose def ping(self): \"\"\"Ping drone, an exception is thrown by TcpClient if drone does not answer\"\"\" self._tcp_client.ping() Instance variables depth Get the current depth in millimeters Returns : depth (int): The depth in millimeters of water column. lights Get or set the brightness of the pioneers bottom canister lights Arguments : brightness (int): Set the brightness of the bottom canister LED's in the range <0, 255> Returns : brightness (int): The brightness of the bottom canister LED's in the range <0, 255> pose Get the current orientation of the drone Returns : pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359. Methods connect def connect ( self ) Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. View Source def connect(self): \"\"\"Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. \"\"\" self._state_watcher.start() self.logs.refresh_log_index() if self._slaveModeEnabled is False: if self._tcp_client._sock is None and not self._tcp_client.isAlive(): self._tcp_client.connect() self._tcp_client.start() try: # Ensure that we are able to communicate with the drone self.ping() except ResponseTimeout as e: raise ConnectionError( f\"Found drone at {self._tcp_client._ip}:{self._tcp_client._port}, \" \"but was unable to establish communication with it. \" \"Is there another client connected?\" ) from e self.motion.update_setpoint() ping def ping ( self ) Ping drone, an exception is thrown by TcpClient if drone does not answer View Source def ping(self): \"\"\"Ping drone, an exception is thrown by TcpClient if drone does not answer\"\"\" self._tcp_client.ping() SlaveModeWarning class SlaveModeWarning ( / , * args , ** kwargs ) Raised when trying to perform action not possible in slave mode View Source class SlaveModeWarning(UserWarning): \"\"\"Raised when trying to perform action not possible in slave mode\"\"\" Ancestors (in MRO) builtins.UserWarning builtins.Warning builtins.Exception builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self. slaveTcpClient class slaveTcpClient ( / , * args , ** kwargs ) A dummy TCP client that warns you if you use any of its functions View Source class slaveTcpClient: \"\"\"A dummy TCP client that warns you if you use any of its functions\"\"\" def __getattr__(self, name): def method(*args): warnings.warn( f\"Unable to call {name}{args} with client in slave mode\", SlaveModeWarning, stacklevel=2, ) return method","title":"Pioneer"},{"location":"reference/blueye/sdk/pioneer/#module-blueyesdkpioneer","text":"View Source #!/usr/bin/env python3 import threading import time import warnings from blueye.protocol import TcpClient, UdpClient from blueye.protocol.exceptions import ResponseTimeout from .camera import Camera from .motion import Motion from .logs import Logs class _PioneerStateWatcher(threading.Thread): \"\"\"Subscribes to UDP messages from the drone and stores the latest data \"\"\" def __init__(self): threading.Thread.__init__(self) self._general_state = None self._calibration_state = None self._udpclient = UdpClient() self._exit_flag = threading.Event() self.daemon = True @property def general_state(self) -> dict: start = time.time() while self._general_state is None: if time.time() - start > 3: raise TimeoutError(\"No state message received from drone\") return self._general_state @property def calibration_state(self) -> dict: start = time.time() while self._calibration_state is None: if time.time() - start > 3: raise TimeoutError(\"No state message received from drone\") return self._calibration_state def run(self): while not self._exit_flag.is_set(): data_packet = self._udpclient.get_data_dict() if data_packet[\"command_type\"] == 1: self._general_state = data_packet elif data_packet[\"command_type\"] == 2: self._calibration_state = data_packet def stop(self): self._exit_flag.set() class SlaveModeWarning(UserWarning): \"\"\"Raised when trying to perform action not possible in slave mode\"\"\" class slaveTcpClient: \"\"\"A dummy TCP client that warns you if you use any of its functions\"\"\" def __getattr__(self, name): def method(*args): warnings.warn( f\"Unable to call {name}{args} with client in slave mode\", SlaveModeWarning, stacklevel=2, ) return method class Pioneer: \"\"\"A class providing a interface to the Blueye pioneer's basic functions Automatically connects to the drone using the default ip and port when instantiated, this behaviour can be disabled by setting `autoConnect=False`. The drone only supports one client controlling it at a time, but if you pass `slaveModeEnabled=True` you will still be able to receive data from the drone. \"\"\" def __init__( self, ip=\"192.168.1.101\", tcpPort=2011, autoConnect=True, slaveModeEnabled=False ): self._ip = ip self._slaveModeEnabled = slaveModeEnabled if slaveModeEnabled: self._tcp_client = slaveTcpClient() else: self._tcp_client = TcpClient(ip=ip, port=tcpPort, autoConnect=autoConnect) self._state_watcher = _PioneerStateWatcher() self.camera = Camera(self._tcp_client, self._state_watcher) self.motion = Motion(self._tcp_client, self._state_watcher) self.logs = Logs(ip=ip, auto_download_index=autoConnect) if autoConnect is True: self.connect() def connect(self): \"\"\"Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. \"\"\" self._state_watcher.start() self.logs.refresh_log_index() if self._slaveModeEnabled is False: if self._tcp_client._sock is None and not self._tcp_client.isAlive(): self._tcp_client.connect() self._tcp_client.start() try: # Ensure that we are able to communicate with the drone self.ping() except ResponseTimeout as e: raise ConnectionError( f\"Found drone at {self._tcp_client._ip}:{self._tcp_client._port}, \" \"but was unable to establish communication with it. \" \"Is there another client connected?\" ) from e self.motion.update_setpoint() @property def lights(self) -> int: \"\"\"Get or set the brightness of the pioneers bottom canister lights *Arguments*: * brightness (int): Set the brightness of the bottom canister LED's in the range <0, 255> *Returns*: * brightness (int): The brightness of the bottom canister LED's in the range <0, 255> \"\"\" state = self._state_watcher.general_state return state[\"lights_upper\"] @lights.setter def lights(self, brightness: int): try: self._tcp_client.set_lights(brightness, 0) except ValueError as e: raise ValueError( \"Error occured while trying to set lights to: \" f\"{brightness}\" ) from e @property def depth(self) -> int: \"\"\"Get the current depth in millimeters *Returns*: * depth (int): The depth in millimeters of water column. \"\"\" return self._state_watcher.general_state[\"depth\"] @property def pose(self) -> dict: \"\"\"Get the current orientation of the drone *Returns*: * pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359. \"\"\" pose = { \"roll\": (self._state_watcher.general_state[\"roll\"] + 360) % 360, \"pitch\": (self._state_watcher.general_state[\"pitch\"] + 360) % 360, \"yaw\": (self._state_watcher.general_state[\"yaw\"] + 360) % 360, } return pose def ping(self): \"\"\"Ping drone, an exception is thrown by TcpClient if drone does not answer\"\"\" self._tcp_client.ping()","title":"Module blueye.sdk.pioneer"},{"location":"reference/blueye/sdk/pioneer/#classes","text":"","title":"Classes"},{"location":"reference/blueye/sdk/pioneer/#pioneer","text":"class Pioneer ( ip = '192.168.1.101' , tcpPort = 2011 , autoConnect = True , slaveModeEnabled = False ) A class providing a interface to the Blueye pioneer's basic functions Automatically connects to the drone using the default ip and port when instantiated, this behaviour can be disabled by setting autoConnect=False . The drone only supports one client controlling it at a time, but if you pass slaveModeEnabled=True you will still be able to receive data from the drone. View Source class Pioneer: \"\"\"A class providing a interface to the Blueye pioneer's basic functions Automatically connects to the drone using the default ip and port when instantiated, this behaviour can be disabled by setting `autoConnect=False`. The drone only supports one client controlling it at a time, but if you pass `slaveModeEnabled=True` you will still be able to receive data from the drone. \"\"\" def __init__( self, ip=\"192.168.1.101\", tcpPort=2011, autoConnect=True, slaveModeEnabled=False ): self._ip = ip self._slaveModeEnabled = slaveModeEnabled if slaveModeEnabled: self._tcp_client = slaveTcpClient() else: self._tcp_client = TcpClient(ip=ip, port=tcpPort, autoConnect=autoConnect) self._state_watcher = _PioneerStateWatcher() self.camera = Camera(self._tcp_client, self._state_watcher) self.motion = Motion(self._tcp_client, self._state_watcher) self.logs = Logs(ip=ip, auto_download_index=autoConnect) if autoConnect is True: self.connect() def connect(self): \"\"\"Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. \"\"\" self._state_watcher.start() self.logs.refresh_log_index() if self._slaveModeEnabled is False: if self._tcp_client._sock is None and not self._tcp_client.isAlive(): self._tcp_client.connect() self._tcp_client.start() try: # Ensure that we are able to communicate with the drone self.ping() except ResponseTimeout as e: raise ConnectionError( f\"Found drone at {self._tcp_client._ip}:{self._tcp_client._port}, \" \"but was unable to establish communication with it. \" \"Is there another client connected?\" ) from e self.motion.update_setpoint() @property def lights(self) -> int: \"\"\"Get or set the brightness of the pioneers bottom canister lights *Arguments*: * brightness (int): Set the brightness of the bottom canister LED's in the range <0, 255> *Returns*: * brightness (int): The brightness of the bottom canister LED's in the range <0, 255> \"\"\" state = self._state_watcher.general_state return state[\"lights_upper\"] @lights.setter def lights(self, brightness: int): try: self._tcp_client.set_lights(brightness, 0) except ValueError as e: raise ValueError( \"Error occured while trying to set lights to: \" f\"{brightness}\" ) from e @property def depth(self) -> int: \"\"\"Get the current depth in millimeters *Returns*: * depth (int): The depth in millimeters of water column. \"\"\" return self._state_watcher.general_state[\"depth\"] @property def pose(self) -> dict: \"\"\"Get the current orientation of the drone *Returns*: * pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359. \"\"\" pose = { \"roll\": (self._state_watcher.general_state[\"roll\"] + 360) % 360, \"pitch\": (self._state_watcher.general_state[\"pitch\"] + 360) % 360, \"yaw\": (self._state_watcher.general_state[\"yaw\"] + 360) % 360, } return pose def ping(self): \"\"\"Ping drone, an exception is thrown by TcpClient if drone does not answer\"\"\" self._tcp_client.ping()","title":"Pioneer"},{"location":"reference/blueye/sdk/pioneer/#instance-variables","text":"depth Get the current depth in millimeters Returns : depth (int): The depth in millimeters of water column. lights Get or set the brightness of the pioneers bottom canister lights Arguments : brightness (int): Set the brightness of the bottom canister LED's in the range <0, 255> Returns : brightness (int): The brightness of the bottom canister LED's in the range <0, 255> pose Get the current orientation of the drone Returns : pose (dict): Dictionary with roll, pitch, and yaw in degrees, from 0 to 359.","title":"Instance variables"},{"location":"reference/blueye/sdk/pioneer/#methods","text":"","title":"Methods"},{"location":"reference/blueye/sdk/pioneer/#connect","text":"def connect ( self ) Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. View Source def connect(self): \"\"\"Start receiving telemetry info from the drone, and publishing watchdog messages When watchdog message are published the thrusters are armed, to stop the drone from moving unexpectedly when connecting all thruster set points are set to zero when connecting. \"\"\" self._state_watcher.start() self.logs.refresh_log_index() if self._slaveModeEnabled is False: if self._tcp_client._sock is None and not self._tcp_client.isAlive(): self._tcp_client.connect() self._tcp_client.start() try: # Ensure that we are able to communicate with the drone self.ping() except ResponseTimeout as e: raise ConnectionError( f\"Found drone at {self._tcp_client._ip}:{self._tcp_client._port}, \" \"but was unable to establish communication with it. \" \"Is there another client connected?\" ) from e self.motion.update_setpoint()","title":"connect"},{"location":"reference/blueye/sdk/pioneer/#ping","text":"def ping ( self ) Ping drone, an exception is thrown by TcpClient if drone does not answer View Source def ping(self): \"\"\"Ping drone, an exception is thrown by TcpClient if drone does not answer\"\"\" self._tcp_client.ping()","title":"ping"},{"location":"reference/blueye/sdk/pioneer/#slavemodewarning","text":"class SlaveModeWarning ( / , * args , ** kwargs ) Raised when trying to perform action not possible in slave mode View Source class SlaveModeWarning(UserWarning): \"\"\"Raised when trying to perform action not possible in slave mode\"\"\"","title":"SlaveModeWarning"},{"location":"reference/blueye/sdk/pioneer/#ancestors-in-mro","text":"builtins.UserWarning builtins.Warning builtins.Exception builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/blueye/sdk/pioneer/#class-variables","text":"args","title":"Class variables"},{"location":"reference/blueye/sdk/pioneer/#methods_1","text":"","title":"Methods"},{"location":"reference/blueye/sdk/pioneer/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/blueye/sdk/pioneer/#slavetcpclient","text":"class slaveTcpClient ( / , * args , ** kwargs ) A dummy TCP client that warns you if you use any of its functions View Source class slaveTcpClient: \"\"\"A dummy TCP client that warns you if you use any of its functions\"\"\" def __getattr__(self, name): def method(*args): warnings.warn( f\"Unable to call {name}{args} with client in slave mode\", SlaveModeWarning, stacklevel=2, ) return method","title":"slaveTcpClient"}]}